# 06 - JVM

> 覆盖 JVM 核心知识：运行时数据区、垃圾回收算法与收集器、类加载机制、调优实战等高频面试考点。

---

## 一、内存模型

### 1. JVM 运行时数据区有哪些？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：JVM 运行时数据区分为线程私有的（程序计数器、虚拟机栈、本地方法栈）和线程共享的（堆、方法区）。

**通俗理解**：

把 JVM 想象成一家公司：
- **程序计数器** = 每个员工手里的"待办清单指针"，记录当前做到哪一步了
- **虚拟机栈** = 每个员工的"办公桌"，桌上摞着一叠文件夹，每接一个任务就加一个文件夹，做完就拿走
- **本地方法栈** = 和办公桌类似，但专门给"外包人员"用的
- **堆** = 公司的"大仓库"，所有采购回来的物资都放在这里
- **方法区** = 公司的"档案室"，存放公司章程、规章制度这些不常变的东西

**回到技术**：上面说的"员工"就是线程，每个线程有自己独立的程序计数器、虚拟机栈和本地方法栈，互不干扰。"大仓库"就是堆内存，所有 `new` 出来的对象都放在堆里，也是 GC（垃圾回收）重点管理的区域。"档案室"就是方法区，存放类的结构信息、常量、静态变量这些。

**原理详解**：

| 区域 | 线程 | 存什么 | 会出什么错 |
|------|------|--------|-----------|
| **程序计数器** | 私有 | 当前线程执行到哪一行字节码 | ⚡**唯一不会 OOM 的区域** |
| **虚拟机栈** | 私有 | 每个方法调用的信息（一个方法 = 一个栈帧） | `StackOverflowError`（递归太深） |
| **本地方法栈** | 私有 | Native 方法（C/C++ 写的底层方法）的调用信息 | `StackOverflowError` |
| **堆** | 共享 | 对象实例、数组 | ⚡`OutOfMemoryError: Java heap space` |
| **方法区** | 共享 | 类信息、常量池、静态变量、JIT 编译后的代码 | `OutOfMemoryError: Metaspace` |

> **栈帧是什么？** 简单说，你每调用一个方法，JVM 就在虚拟机栈上"压"一个栈帧，里面装着这个方法的局部变量、中间计算结果等。方法执行完，栈帧就弹出去了。递归调用太深，栈帧摞太多，就会 StackOverflow。

**方法区的演变**：
- JDK 7 及之前：方法区由 **永久代（PermGen，一块固定大小的内存）** 实现，大小写死，容易 OOM
- JDK 8 及之后：永久代被移除，改为 **元空间（Metaspace，直接使用操作系统的内存）**，默认不设上限，更灵活

**🎤 面试这样答**：
> "JVM 运行时数据区分为线程私有和线程共享两部分。线程私有的有程序计数器、虚拟机栈和本地方法栈，其中程序计数器是唯一不会 OOM 的区域。线程共享的有堆和方法区，堆是 GC 的主要区域，存放对象实例；方法区存放类信息和常量池，JDK 8 之后由元空间实现，使用本地内存而不是 JVM 堆内存。"

---

### 2. 堆内存的分代模型是怎样的？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：堆分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区，比例默认 8:1:1。

**通俗理解**：

把堆想象成一个"人才市场"：
- **新生代（Young Generation）** = "实习区"，新来的员工都先到这里。大部分实习生干不了几天就走了（对象朝生夕死），所以这里人员流动很快
  - **Eden 区** = "面试大厅"，所有新人首先在这里报到
  - **Survivor 区（S0/S1）** = "考察区"，经过一轮淘汰（Minor GC）活下来的人在这两个区之间轮换考察
- **老年代（Old Generation）** = "正式员工区"，经过多轮考核还留下来的人转正到这里，不会轻易被裁

**回到技术**：新对象优先在 Eden 区分配内存。当 Eden 满了，触发一次 **Minor GC（只清理新生代的垃圾回收）**，存活的对象被复制到 Survivor 区，每熬过一次 GC 年龄 +1。当年龄达到阈值（默认 ⚡**15 次**），对象就会被移到老年代。

**原理详解**：

```
                        堆内存（Heap）
┌──────────────────────────────┬─────────────────────┐
│        新生代（Young）1/3     │   老年代（Old）2/3   │
│  ┌────────┬──────┬──────┐   │                     │
│  │ Eden   │  S0  │  S1  │   │                     │
│  │  8/10  │ 1/10 │ 1/10 │   │                     │
│  └────────┴──────┴──────┘   │                     │
└──────────────────────────────┴─────────────────────┘
```

**对象什么时候进老年代？** 三种情况：

1. **年龄够了**：每经历一次 Minor GC 年龄 +1，达到 ⚡**15**（默认，可通过 `-XX:MaxTenuringThreshold` 调整）就晋升
2. **大对象直接进**：超过 `-XX:PretenureSizeThreshold` 的大对象直接分配在老年代，省得在 Eden 和 Survivor 之间来回复制
3. **动态年龄判断**：Survivor 区中相同年龄的对象大小总和超过 Survivor 空间的 ⚡**50%**，则年龄 ≥ 该年龄的对象直接晋升（不用等到 15 次）

**🎤 面试这样答**：
> "堆内存分为新生代和老年代，默认比例 1:2。新生代又分为 Eden 和两个 Survivor 区，比例 8:1:1。新对象优先在 Eden 分配，Minor GC 时存活对象复制到 Survivor 区，年龄每次 +1，达到 15 次晋升老年代。大对象会直接进入老年代。另外还有动态年龄判断机制，Survivor 中同龄对象超过空间一半时会提前晋升。"

---

### 3. 对象在内存中的布局是怎样的？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：HotSpot 中，一个对象在堆内存里由三部分组成：**对象头**、**实例数据**、**对齐填充**。你可以把它想象成一个快递包裹——对象头是包裹上的面单（记录寄件人、重量等元信息），实例数据是包裹里的东西（你的字段值），对齐填充是为了凑整塞的泡沫（让对象大小是 8 字节的整数倍）。

| 部分 | 装了什么 | 大小 |
|------|---------|------|
| **对象头 - Mark Word** | 哈希码、GC 年龄（就是上面说的"熬过几次 GC"）、锁状态 | ⚡**8 字节**（64 位系统） |
| **对象头 - 类型指针** | 指向"我是哪个类的实例"的指针 | 4 字节（开启压缩）/ 8 字节 |
| **对象头 - 数组长度** | 仅数组对象有 | 4 字节 |
| **实例数据** | 对象的字段内容（包括从父类继承的） | 按字段类型而定 |
| **对齐填充** | 凑整用，保证对象大小是 ⚡**8 字节**的整数倍 | 0~7 字节 |

> 默认开启指针压缩（`-XX:+UseCompressedOops`），类型指针从 8 字节压缩为 ⚡**4 字节**，能节省不少内存。

---

## 二、垃圾回收

### 4. 如何判断对象是否可以被回收？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：主流用 **可达性分析算法**，从 GC Roots 出发，不可达的对象就是垃圾。

**通俗理解**：

想象你在整理房间，要扔掉没用的东西。你从"绝对不能扔的清单"开始——钥匙串要留，钥匙串上挂着的钥匙也要留，钥匙能打开的抽屉里的东西也要留……顺着关联一路找下去。最后，所有没被关联到的东西就是垃圾，可以扔了。

**回到技术**：上面说的"绝对不能扔的清单"就是 **GC Roots（垃圾回收的根节点）**，"关联"就是对象之间的引用关系。GC 从这些根节点出发，沿着引用链一路遍历，能走到的对象就是"活的"，走不到的就是"死的"，可以回收。

**原理详解**：

**哪些东西算 GC Roots？** 记住这几个就够面试用了：

1. **虚拟机栈中的局部变量**——方法还在执行，里面用到的对象当然不能回收
2. **static 静态变量引用的对象**——类还在，静态变量指向的对象就得留着
3. **常量引用的对象**——`static final` 指向的对象
4. **Native 方法中 JNI 引用的对象**——C/C++ 代码还在用的 Java 对象
5. **被 synchronized 锁住的对象**——锁还没释放，对象不能回收

**为什么不用引用计数法？**

| 算法 | 怎么判断 | 优点 | 致命缺点 |
|------|---------|------|---------|
| 引用计数法 | 每个对象记录"有几个人引用我" | 简单高效 | ⚡**无法解决循环引用**（A 引用 B，B 引用 A，计数永远不为 0） |
| **可达性分析** | 从 GC Roots 沿引用链遍历 | 能处理循环引用 | 遍历时需要 **STW（Stop The World，暂停所有业务线程）** |

**🎤 面试这样答**：
> "Java 用可达性分析算法判断对象是否存活。从 GC Roots 出发，沿着引用链遍历，不可达的对象就是垃圾。GC Roots 包括虚拟机栈中的局部变量、方法区中的静态变量和常量、本地方法栈中的 JNI 引用等。没有用引用计数法是因为它无法解决循环引用问题——两个对象互相引用，计数永远不为 0，但实际上它们已经没人用了。"

---

### 5. 垃圾回收算法有哪些？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：三种基础算法——标记-清除、标记-复制、标记-整理，实际收集器多采用分代组合策略。

**通俗理解**：

你家仓库堆满了东西，要清理垃圾。三种清理方式：

- **标记-清除** = 先在垃圾上贴标签，然后把贴了标签的扔掉。简单粗暴，但扔完后仓库里东一个空位西一个空位，想放个大件都放不下
- **标记-复制** = 把仓库一分为二，把有用的东西搬到另一半，然后把原来那半全部清空。整齐干净，但你只能用一半的仓库
- **标记-整理** = 先贴标签，然后把有用的东西全部推到仓库一头，再清理尾部空间。不浪费空间，但搬东西很累

**回到技术**：上面说的"东一个空位西一个空位"就是 **内存碎片（Memory Fragmentation）**，碎片多了之后，即使总空闲内存够用，也可能分配不了大对象。"只能用一半仓库"就是复制算法浪费 50% 空间的代价。"搬东西很累"就是整理算法移动对象的开销。

**原理详解**：

| 算法 | 过程 | 优点 | 缺点 | 用在哪 |
|------|------|------|------|--------|
| **标记-清除** | 标记存活对象 → 清除未标记的 | 简单 | 产生内存碎片 | CMS 老年代 |
| **标记-复制** | 存活对象复制到另一块 → 清空原区域 | 无碎片、速度快 | ⚡**浪费 50% 空间** | **新生代** |
| **标记-整理** | 存活对象向一端移动 → 清理边界外 | 无碎片、不浪费 | 移动对象开销大 | **老年代** |

**为什么新生代用复制算法？** 因为新生代里 ⚡**约 98% 的对象都活不过一次 GC**，需要复制的对象很少，所以复制算法又快又划算。而且 Eden:S0:S1 = 8:1:1 的设计只浪费 10% 空间，不是真的浪费一半。

**🎤 面试这样答**：
> "垃圾回收有三种基础算法。标记-清除最简单但会产生内存碎片；标记-复制没有碎片但浪费空间，适合新生代因为大部分对象朝生夕死，需要复制的很少；标记-整理不浪费空间也没碎片，但移动对象开销大，适合老年代。实际的收集器采用分代收集策略，新生代用复制算法，老年代用标记-清除或标记-整理。"

---

### 6. 常见的垃圾收集器有哪些？CMS 和 G1 的区别？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：常见收集器有 Serial、Parallel、CMS、G1、ZGC。CMS 追求最短停顿但有碎片问题，G1 兼顾吞吐量和停顿且可预测停顿时间。

**通俗理解**：

垃圾收集器就像不同的"保洁方案"：
- **Serial** = 一个保洁阿姨打扫，打扫时所有人都得出去等着。适合小办公室
- **Parallel** = 一群保洁阿姨同时打扫，速度快但大家还是得出去等。追求"打扫总量最大化"
- **CMS** = 保洁边打扫你边工作，尽量不打扰你，但地上会留碎屑
- **G1** = 把办公室分成很多小格子，哪个格子最脏先打扫哪个，还能预估"打扫多久你需要等"
- **ZGC** = 黑科技保洁，几乎不用你停下来

**回到技术**：上面说的"所有人出去等"就是 **STW（Stop The World，暂停所有业务线程让 GC 干活）**。STW 时间越长，用户感受到的卡顿越明显。CMS 和 G1 的核心目标都是减少 STW 时间，但实现方式不同。"碎屑"就是 CMS 用标记-清除算法产生的内存碎片。"小格子"就是 G1 把堆划分成的 Region。

**原理详解**：

**面试重点掌握这三个**（Serial/Parallel 了解即可）：

**① CMS（Concurrent Mark Sweep）—— 老年代收集器**

CMS 的目标是"尽量少停顿"，分四个阶段：

1. **初始标记**（⚡需要 STW，但很快）：只标记 GC Roots 直接关联的对象，范围小所以快
2. **并发标记**（不停顿）：和你的业务线程同时运行，遍历整个对象图，找出所有存活对象
3. **重新标记**（⚡需要 STW）：修正第 2 步期间业务线程改动过的引用关系
4. **并发清除**（不停顿）：和业务线程同时运行，清除垃圾对象

CMS 的问题：用标记-清除算法，会产生内存碎片；并发阶段占用 CPU；如果并发清理时老年代又满了（**Concurrent Mode Failure**），会退化成单线程的 Serial Old，停顿时间暴增。

**② G1（Garbage First）—— ⚡JDK 9+ 默认收集器**

G1 的核心设计：
- 把堆划分为大小相等的 **Region（区域）**，默认 ⚡**2048 个**，每个 Region 可以扮演 Eden/Survivor/Old 任意角色
- 维护一个"垃圾最多排行榜"，优先回收垃圾最多的 Region（这就是 Garbage First 名字的由来）
- 通过 `-XX:MaxGCPauseMillis`（默认 ⚡**200ms**）设置"我最多能等多久"，G1 会尽量在这个时间内完成回收
- Region 之间用复制算法，整体效果是标记-整理，**不会产生碎片**

**③ ZGC —— 超低延迟收集器（JDK 11+）**

停顿时间 ⚡**< 1ms**，不管堆多大。适合超大堆（TB 级）和对延迟极度敏感的场景。

**补充了解：Serial 和 Parallel**

| 收集器 | 线程 | 特点 | 适用场景 |
|--------|------|------|---------|
| **Serial** | 单线程 | 简单高效，STW 时间长 | 客户端模式、小堆（几十 MB） |
| **Parallel** | 多线程 | ⚡**JDK 8 默认**，追求高吞吐量 | 后台计算型任务 |

**🎤 面试这样答**：
> "CMS 是老年代收集器，用标记-清除算法，分四个阶段，其中并发标记和并发清除与用户线程并行，所以停顿时间短。但缺点是会产生内存碎片，而且并发阶段占用 CPU。G1 是 JDK 9 之后的默认收集器，把堆分成多个 Region，优先回收垃圾最多的 Region，可以通过 MaxGCPauseMillis 设置期望停顿时间。G1 用复制算法处理 Region，不会产生碎片。对于超大堆和低延迟场景，JDK 11+ 可以考虑 ZGC，停顿在 1ms 以内。"

---

### 7. Minor GC、Major GC、Full GC 的区别？

> ⭐⭐⭐ 常问 | 难度：⭐⭐

**回答**：简单说，这三种 GC 的区别就是"打扫范围"不同——Minor GC 只扫新生代，Major GC 只扫老年代，Full GC 全家一起扫（堆 + 方法区）。打扫范围越大，耗时越长，对业务影响越大。

| GC 类型 | 打扫哪里 | 什么时候触发 | 速度 |
|---------|---------|-------------|------|
| **Minor GC** | 新生代 | Eden 区满了 | ⚡快（通常 **几ms ~ 几十ms**） |
| **Major GC** | 老年代 | 老年代空间不足 | 比 Minor GC 慢 ⚡**10 倍以上** |
| **Full GC** | **整个堆 + 方法区** | 见下方触发条件 | 最慢，应尽量避免 |

**什么情况会触发 Full GC？** 这个面试常追问：

1. 老年代空间不足
2. 方法区（元空间）不足
3. 代码里调了 `System.gc()`（建议用 `-XX:+DisableExplicitGC` 禁掉）
4. CMS 的 **Concurrent Mode Failure**（并发清理时老年代又满了，被迫退化成全量回收）
5. Minor GC 后存活对象太多，老年代放不下（晋升失败）

---

### 8. 强引用、软引用、弱引用、虚引用的区别？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：四种引用强度递减，决定了对象在 GC 时的存活优先级。

**通俗理解**：

把对象想象成你手里抓着的气球：
- **强引用** = 用铁链拴着，刮台风也不会飞走。只要链子在，GC 绝不回收，宁可 OOM 也不动它
- **软引用** = 用绳子牵着，风大了（内存不够了）才放手
- **弱引用** = 用棉线牵着，只要有风（GC 一来）就断了
- **虚引用** = 根本没牵，气球已经飞了，你只是收到一个"气球飞走了"的通知

**回到技术**："铁链"就是我们平时写的 `Object o = new Object()` 这种普通赋值。"绳子"是 `SoftReference`，内存够用时不回收，内存紧张时才回收，特别适合做缓存。"棉线"是 `WeakReference`，下次 GC 就回收，ThreadLocal 内部就用了弱引用。"通知"是 `PhantomReference`，配合 `ReferenceQueue` 使用，用来跟踪对象什么时候被回收了。

**原理详解**：

| 引用类型 | 类 | GC 什么时候回收 | 典型用途 |
|----------|-----|----------------|---------|
| **强引用** | 直接赋值 `Object o = new Object()` | 引用存在就⚡**永不回收** | 日常使用 |
| **软引用** | `SoftReference<T>` | ⚡**内存不足时**才回收 | 缓存（如图片缓存） |
| **弱引用** | `WeakReference<T>` | ⚡**下次 GC 时**必定回收 | `WeakHashMap`、`ThreadLocal` |
| **虚引用** | `PhantomReference<T>` | 随时回收，无法通过它获取对象 | 跟踪回收时机、管理堆外内存 |

```java
// 软引用：内存不够时才回收，适合做缓存
SoftReference<byte[]> soft = new SoftReference<>(new byte[1024 * 1024]);
System.out.println(soft.get());  // 内存充足时能拿到对象

// 弱引用：下次 GC 就回收
WeakReference<Object> weak = new WeakReference<>(new Object());
System.gc();  // 触发 GC
System.out.println(weak.get());  // null —— 已被回收
```

**🎤 面试这样答**：
> "Java 有四种引用类型，强度依次递减。强引用就是普通赋值，GC 不会回收；软引用在内存不足时回收，适合做缓存；弱引用在下次 GC 时就会被回收，ThreadLocal 的 Entry 就用了弱引用防止内存泄漏；虚引用无法获取对象，主要配合 ReferenceQueue 跟踪对象回收时机，NIO 的 DirectByteBuffer 就用虚引用管理堆外内存。"

---

## 三、类加载

### 9. 类的加载过程是怎样的？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：类的生命周期分为加载、验证、准备、解析、初始化五个阶段，其中验证、准备、解析统称为连接。

**通俗理解**：

把类加载想象成一个新员工入职流程：

1. **加载** = HR 收到简历，把简历存进公司系统（把 .class 文件的字节码读进内存）
2. **验证** = 背景调查，确认简历没造假、学历是真的（检查字节码格式是否合法，不会危害 JVM）
3. **准备** = 分配工位，先贴个名牌但还没正式开工（给 static 变量分配内存，赋**零值**而不是代码里写的值）
4. **解析** = 把"找张三"这种名字换成工位号（把符号引用替换成直接引用，也就是把类名、方法名变成内存地址）
5. **初始化** = 正式开工，执行入职培训（执行 static 代码块和 static 变量的赋值）

**回到技术**：上面说的"简历"就是 .class 字节码文件，"公司系统"就是 JVM 内存中的方法区。"贴名牌赋零值"是准备阶段的关键——比如你写了 `static int x = 10`，准备阶段 x 的值是 ⚡**0 而不是 10**，要等到初始化阶段才会赋值为 10。"符号引用变直接引用"就是把代码里的类名字符串变成实际的内存指针。

**原理详解**：

```
        加载 → 验证 → 准备 → 解析 → 初始化 → 使用 → 卸载
               └──── 连接 ────┘
```

| 阶段 | 干了什么 | 关键细节 |
|------|---------|---------|
| **加载** | 读取 .class 文件，生成 Class 对象 | 可以从 jar、网络、动态代理等来源加载 |
| **验证** | 检查字节码合法性 | 文件格式、元数据、字节码、符号引用四种验证 |
| **准备** | 给 static 变量分配内存并赋零值 | ⚡`static int x = 10` → 准备阶段 x = **0** |
| **解析** | 符号引用 → 直接引用 | 类、字段、方法的引用都要解析 |
| **初始化** | 执行 `<clinit>()` 方法 | 按代码顺序执行 static 赋值和 static 代码块 |

> **特殊情况**：`static final` 修饰的**编译期常量**（如 `static final int x = 10`）在准备阶段就直接赋值为 10，不用等到初始化。但如果是 `static final Object o = new Object()`，因为 `new` 要在运行时才能执行，所以还是得等初始化阶段。

**🎤 面试这样答**：
> "类加载分为五个阶段：加载、验证、准备、解析、初始化。加载阶段把 .class 文件读入内存并生成 Class 对象；验证阶段检查字节码合法性；准备阶段给 static 变量分配内存并赋零值，注意不是代码里写的值；解析阶段把符号引用替换为直接引用；初始化阶段才真正执行 static 赋值和 static 代码块。其中 static final 的编译期常量会在准备阶段直接赋值。"

---

### 10. 什么是双亲委派模型？为什么需要它？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：类加载时先让父加载器尝试加载，父加载器加载不了才自己加载，这就是双亲委派。目的是保证核心类库的安全和唯一性。

**通俗理解**：

想象你是一个小学生，遇到不会做的作业：
1. 你先问**爸爸**（Application ClassLoader，应用类加载器）
2. 爸爸说"我也不确定，问你**爷爷**"（Extension ClassLoader，扩展类加载器）
3. 爷爷说"我也不会，问**老祖宗**"（Bootstrap ClassLoader，启动类加载器）
4. 老祖宗看了看，如果是他擅长的（`java.lang.*` 这些核心类），他就直接教你
5. 如果老祖宗不会，就退回给爷爷；爷爷不会，再退回给爸爸；爸爸也不会，最后才轮到你自己想办法

关键是：**永远先往上问，上面搞不定才自己来**。

**回到技术**：上面说的"问长辈"就是把加载请求委派给父类加载器。"老祖宗"是 **Bootstrap ClassLoader（启动类加载器，C++ 实现，加载 `rt.jar` 等核心类库）**，"爷爷"是 **Extension ClassLoader（加载 `jre/lib/ext` 目录的扩展类）**，"爸爸"是 **Application ClassLoader（加载你项目 classpath 下的类）**。这样做的好处是：即使你自己写了一个 `java.lang.String`，也不会被加载，因为 Bootstrap 已经加载了 JDK 自带的 String，保证了核心类不被篡改。

**原理详解**：

```
        Bootstrap ClassLoader（启动类加载器）
        加载：rt.jar、核心类库（java.lang.* 等）
                    ↑ 委派
        Extension ClassLoader（扩展类加载器）
        加载：jre/lib/ext 目录
                    ↑ 委派
        Application ClassLoader（应用类加载器）
        加载：classpath 下的类（你写的代码）
                    ↑ 委派
        自定义 ClassLoader（如有）
```

**加载流程**（以加载 `com.example.User` 为例）：

1. Application ClassLoader 收到请求，不急着自己加载，先交给 Extension ClassLoader
2. Extension ClassLoader 也不急，先交给 Bootstrap ClassLoader
3. Bootstrap 发现这不是核心类，加载不了，退回给 Extension
4. Extension 发现 ext 目录也没有，退回给 Application
5. Application 在 classpath 下找到了，加载成功

**为什么需要双亲委派？**

| 原因 | 说明 |
|------|------|
| **安全** | 防止用户自定义的类冒充核心类（比如自己写个 `java.lang.String` 来窃取数据） |
| **唯一性** | 保证同一个类只被加载一次，不会出现两个不同的 `String` 类 |

**什么时候会打破双亲委派？**

1. **SPI 机制**（如 JDBC）：核心类库需要加载第三方实现，但 Bootstrap 加载不了 classpath 的类，所以用 **线程上下文类加载器（Thread Context ClassLoader）** 反向委托给 Application ClassLoader
2. **热部署/热加载**：Tomcat 为每个 Web 应用创建独立的类加载器，优先加载自己目录下的类，实现应用隔离
3. **OSGi 模块化**：每个模块有自己的类加载器，形成网状结构而非树状

**🎤 面试这样答**：
> "双亲委派模型是指类加载时先委派给父加载器，父加载器加载不了才自己加载。三层加载器分别是：Bootstrap 加载核心类库，Extension 加载扩展类，Application 加载 classpath 下的类。这样做的好处是保证核心类的安全和唯一性，比如自定义的 java.lang.String 不会被加载。但有些场景需要打破双亲委派，比如 JDBC 的 SPI 机制通过线程上下文类加载器让核心类库加载第三方驱动，Tomcat 为每个应用创建独立类加载器实现隔离。"

---

## 四、实战调优

### 11. 常用的 JVM 调优参数有哪些？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：JVM 调优主要调堆大小、GC 收集器选择、GC 日志输出三大类参数。

**通俗理解**：

JVM 调优就像给汽车调发动机参数——油箱多大（堆内存）、用什么型号的发动机（GC 收集器）、要不要装行车记录仪（GC 日志）。不同的路况（业务场景）需要不同的配置。

**回到技术**："油箱大小"就是 `-Xms`（初始堆）和 `-Xmx`（最大堆），生产环境一般设成一样大，避免堆动态扩缩容带来的性能抖动。"发动机型号"就是选择 G1、ZGC 还是 Parallel 等收集器。"行车记录仪"就是 GC 日志，出问题时靠它排查。

**原理详解**：

**① 堆内存参数**（最常调的）

| 参数 | 含义 | 推荐值 |
|------|------|--------|
| `-Xms` | 初始堆大小 | ⚡**和 -Xmx 设成一样** |
| `-Xmx` | 最大堆大小 | 物理内存的 ⚡**50%~75%** |
| `-Xmn` | 新生代大小 | 一般不手动设，让 G1 自动管理 |
| `-Xss` | 每个线程的栈大小 | 默认 ⚡**1MB**，递归多可以调大 |

**② GC 收集器选择**

| 参数 | 选择的收集器 |
|------|-------------|
| `-XX:+UseG1GC` | G1（⚡**JDK 9+ 默认**） |
| `-XX:+UseZGC` | ZGC（JDK 11+，超低延迟） |
| `-XX:+UseParallelGC` | Parallel（⚡**JDK 8 默认**，高吞吐） |

**③ GC 日志**（排查问题必备）

```bash
# JDK 8
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/gc.log

# JDK 9+（统一日志框架）
-Xlog:gc*:file=/path/gc.log:time,level,tags
```

**④ 实用的调试参数**

| 参数 | 作用 |
|------|------|
| `-XX:+HeapDumpOnOutOfMemoryError` | ⚡OOM 时自动导出堆快照，**生产必加** |
| `-XX:HeapDumpPath=/path/dump.hprof` | 指定堆快照保存路径 |
| `-XX:MaxMetaspaceSize=256m` | 限制元空间大小，防止无限增长 |

**🎤 面试这样答**：
> "JVM 调优我主要关注三方面：一是堆内存，-Xms 和 -Xmx 设成一样避免动态扩缩容；二是选择合适的 GC 收集器，JDK 8 默认 Parallel，JDK 9+ 默认 G1，低延迟场景可以用 ZGC；三是开启 GC 日志和 HeapDumpOnOutOfMemoryError，方便线上排查问题。"

---

### 12. 线上出现 OOM，你会怎么排查？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐⭐

**一句话回答**：先保留现场（堆快照），再用工具分析内存中哪些对象占了最多空间，定位到代码中的内存泄漏点。

**通俗理解**：

线上 OOM 就像家里水管爆了：
1. **先拍照留证据**（保留堆快照 dump 文件）——不要急着重启，重启了现场就没了
2. **找到漏水点**（分析 dump，看哪些对象占了最多内存）——是马桶漏了还是水龙头没关？
3. **修水管**（定位到代码，修复内存泄漏）——找到那行不断 `new` 对象却不释放的代码

**回到技术**："拍照"就是获取 **堆转储文件（Heap Dump，.hprof 格式）**，里面记录了 OOM 那一刻堆内存中所有对象的信息。"找漏水点"就是用 MAT 或 VisualVM 等工具分析 dump 文件，找出占内存最多的对象和它们的引用链。"修水管"就是根据引用链定位到代码中创建这些对象的位置。

**原理详解**：

**排查四步走**：

**第 1 步：获取堆快照**

```bash
# 方式一：提前配置，OOM 时自动导出（推荐，生产必加）
-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/dump.hprof

# 方式二：手动导出（进程还活着的时候）
jmap -dump:format=b,file=/tmp/dump.hprof <pid>
```

**第 2 步：用工具分析 dump 文件**

| 工具 | 特点 |
|------|------|
| **MAT（Eclipse Memory Analyzer）** | 最强大，能自动分析泄漏嫌疑对象，⚡**首选** |
| VisualVM | JDK 自带，轻量级，适合快速查看 |
| Arthas（阿里开源） | 在线诊断，不用下载 dump 文件 |

**第 3 步：定位问题**

在 MAT 中重点看两个东西：
- **Dominator Tree（支配树）**：按对象占用内存从大到小排序，一眼看出谁最"胖"
- **Leak Suspects（泄漏嫌疑报告）**：MAT 自动分析，直接告诉你"这个对象可能泄漏了"

**第 4 步：常见 OOM 原因和解决方案**

| OOM 类型 | 常见原因 | 解决思路 |
|----------|---------|---------|
| `Java heap space` | 内存泄漏（集合只加不删）、大查询没分页 | 修复泄漏点，加分页 |
| `Metaspace` | 动态生成太多类（如 CGLIB 代理滥用） | 限制 MaxMetaspaceSize，排查类加载 |
| `unable to create new native thread` | 线程创建太多 | 用线程池，调小 -Xss |

**🎤 面试这样答**：
> "线上 OOM 排查我会分四步：第一，确保提前配置了 HeapDumpOnOutOfMemoryError 参数，OOM 时自动导出堆快照；第二，用 MAT 工具分析 dump 文件，看 Dominator Tree 找出占内存最大的对象；第三，通过对象的引用链定位到代码中的泄漏点；第四，根据具体原因修复，比如集合只加不删导致的内存泄漏、大查询没分页等。常见的 OOM 类型有 heap space、Metaspace 和 native thread，排查思路各不相同。"

---

### 13. new 一个对象时，JVM 内部经历了什么？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：简单说，`new` 一个对象就像网购下单——先检查商品是否上架（类有没有加载），然后分配仓位（分配内存），贴好标签（设置对象头），最后执行你的定制需求（调用构造方法）。整个过程分五步：

1. **类加载检查**：JVM 先检查这个类是否已经被加载、解析、初始化过。如果没有，先触发类加载（参考第 9 题）

2. **分配内存**：在堆中划出一块空间。分配方式取决于堆内存是否规整：
   - **指针碰撞（Bump the Pointer）**：堆内存规整时（用过的在一边，空闲的在另一边），只需把分界指针往空闲方向移动对象大小的距离
   - **空闲列表（Free List）**：堆内存不规整时，JVM 维护一个列表记录哪些内存块可用，从中找一块够大的

3. **处理并发安全**：多个线程同时 `new` 对象怎么办？两种方案：
   - **CAS + 失败重试**：用原子操作保证分配的线程安全
   - **TLAB（Thread Local Allocation Buffer）**：每个线程预先分配一小块私有内存，各自在自己的 TLAB 上分配，互不干扰。⚡**默认开启**

4. **初始化零值**：把分配到的内存空间全部置为零值（`int` 为 0，`boolean` 为 false，引用为 null）。这就是为什么成员变量不赋值也有默认值

5. **设置对象头**：填入 Mark Word（哈希码、GC 年龄、锁标志）和类型指针（指向哪个 Class）

6. **执行构造方法**：调用 `<init>()` 方法，执行你代码里写的构造函数逻辑

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | JVM 运行时数据区有哪些？ |
| ⭐⭐⭐⭐⭐ | 如何判断对象是否可以被回收？ |
| ⭐⭐⭐⭐⭐ | 垃圾回收算法有哪些？ |
| ⭐⭐⭐⭐⭐ | CMS 和 G1 的区别？ |
| ⭐⭐⭐⭐⭐ | 什么是双亲委派模型？ |
| ⭐⭐⭐⭐ | 堆内存的分代模型 |
| ⭐⭐⭐⭐ | 强引用、软引用、弱引用、虚引用 |
| ⭐⭐⭐⭐ | 类的加载过程 |
| ⭐⭐⭐⭐ | 常用 JVM 调优参数 |
| ⭐⭐⭐⭐ | 线上 OOM 排查 |
| ⭐⭐⭐ | 对象在内存中的布局 |
| ⭐⭐⭐ | Minor GC、Major GC、Full GC 的区别 |
| ⭐⭐⭐ | new 一个对象的过程 |
