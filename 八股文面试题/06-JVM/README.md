# 06 - JVM

> 覆盖 JVM 核心知识：运行时数据区、垃圾回收算法与收集器、类加载机制、调优实战等高频面试考点。

---

## 一、内存模型

### 1. JVM 运行时数据区有哪些？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：JVM 运行时数据区分为线程私有的（程序计数器、虚拟机栈、本地方法栈）和线程共享的（堆、方法区）。

**通俗理解**：

把 JVM 想象成一家公司：
- **程序计数器** = 每个员工手里的"待办清单指针"，记录当前做到哪一步了（线程私有，不会 OOM）
- **虚拟机栈** = 每个员工的"办公桌"，桌上摞着一叠文件夹（栈帧），每调用一个方法就加一个文件夹，方法结束就拿走（线程私有）
- **本地方法栈** = 和虚拟机栈类似，但专门给"外包人员"（Native 方法）用的
- **堆** = 公司的"大仓库"，所有 new 出来的对象都放在这里（线程共享，GC 主战场）
- **方法区** = 公司的"档案室"，存放类信息、常量、静态变量（线程共享）

**原理详解**：

| 区域 | 线程 | 存储内容 | 异常 |
|------|------|----------|------|
| **程序计数器** | 私有 | 当前线程执行的字节码行号 | ⚡**唯一不会 OOM 的区域** |
| **虚拟机栈** | 私有 | 栈帧（局部变量表、操作数栈、动态链接、返回地址） | `StackOverflowError` / `OOM` |
| **本地方法栈** | 私有 | Native 方法的调用信息 | `StackOverflowError` / `OOM` |
| **堆** | 共享 | 对象实例、数组 | ⚡`OutOfMemoryError: Java heap space` |
| **方法区** | 共享 | 类信息、常量池、静态变量、JIT 编译后的代码 | `OutOfMemoryError: Metaspace` |

**方法区的演变**：
- JDK 7 及之前：方法区由 **永久代（PermGen）** 实现，大小固定，容易 OOM
- JDK 8 及之后：永久代被移除，改为 **元空间（Metaspace）**，使用 ⚡**本地内存（Native Memory）**，默认不设上限

**🎤 面试这样答**：
> "JVM 运行时数据区分为线程私有和线程共享两部分。线程私有的有程序计数器、虚拟机栈和本地方法栈，其中程序计数器是唯一不会 OOM 的区域。线程共享的有堆和方法区，堆是 GC 的主要区域，存放对象实例；方法区存放类信息和常量池，JDK 8 之后由元空间实现，使用本地内存。虚拟机栈中每个方法调用会创建一个栈帧，包含局部变量表、操作数栈等。"

---

### 2. 堆内存的分代模型是怎样的？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：堆分为新生代和老年代，新生代又分为 Eden 区和两个 Survivor 区，比例默认 8:1:1。

**通俗理解**：

把堆想象成一个"人才市场"：
- **新生代（Young Generation）** = "实习区"，新来的对象都先到这里。大部分对象朝生夕死，GC 很频繁但很快
  - **Eden 区** = "面试大厅"，新对象首先在这里分配
  - **Survivor 区（S0/S1）** = "候选区"，经过一轮筛选（Minor GC）活下来的对象在这两个区之间来回倒腾
- **老年代（Old Generation）** = "正式员工区"，经过多轮考核（默认 ⚡**15 次** GC）还活着的对象晋升到这里

**原理详解**：

```
                        堆内存（Heap）
┌──────────────────────────────┬─────────────────────┐
│        新生代（Young）1/3     │   老年代（Old）2/3   │
│  ┌────────┬──────┬──────┐   │                     │
│  │ Eden   │  S0  │  S1  │   │                     │
│  │  8/10  │ 1/10 │ 1/10 │   │                     │
│  └────────┴──────┴──────┘   │                     │
└──────────────────────────────┴─────────────────────┘
```

**对象晋升老年代的条件**：
1. 年龄达到阈值：每经历一次 Minor GC 年龄 +1，达到 ⚡**15**（默认，`-XX:MaxTenuringThreshold`）晋升
2. **大对象直接进老年代**：超过 `-XX:PretenureSizeThreshold` 的对象直接分配在老年代，避免在 Eden 和 Survivor 之间来回复制
3. **动态年龄判断**：Survivor 区中相同年龄的对象大小总和超过 Survivor 空间的 ⚡**50%**，则年龄 ≥ 该年龄的对象直接晋升

**🎤 面试这样答**：
> "堆内存分为新生代和老年代，默认比例 1:2。新生代又分为 Eden 和两个 Survivor 区，比例 8:1:1。新对象优先在 Eden 分配，Minor GC 时存活对象复制到 Survivor 区，年龄每次 +1，达到 15 次晋升老年代。大对象会直接进入老年代。另外还有动态年龄判断机制，Survivor 中同龄对象超过空间一半时会提前晋升。"

---

### 3. 对象在内存中的布局是怎样的？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：HotSpot 中，对象在堆内存中的布局分为三部分：**对象头（Header）**、**实例数据（Instance Data）**、**对齐填充（Padding）**。

| 部分 | 内容 | 大小 |
|------|------|------|
| **对象头 - Mark Word** | 哈希码、GC 分代年龄、锁状态标志、线程持有的锁等 | ⚡**8 字节**（64 位） |
| **对象头 - 类型指针** | 指向类元数据（Class Metadata）的指针 | 4 字节（开启压缩指针）/ 8 字节 |
| **对象头 - 数组长度** | 仅数组对象有，记录数组长度 | 4 字节 |
| **实例数据** | 对象的字段内容（包括父类继承的） | 按字段类型大小 |
| **对齐填充** | 保证对象大小是 ⚡**8 字节**的整数倍 | 0~7 字节 |

> 开启指针压缩（`-XX:+UseCompressedOops`，默认开启）后，类型指针从 8 字节压缩为 ⚡**4 字节**。

---

## 二、垃圾回收

### 4. 如何判断对象是否可以被回收？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：主流用 **可达性分析算法**，从 GC Roots 出发，不可达的对象就是垃圾。

**通俗理解**：

想象你在整理房间，要扔掉没用的东西。你从"必须留下的物品清单"（GC Roots）开始，顺着每件物品的关联找下去——钥匙串上挂着的钥匙要留，钥匙能打开的抽屉里的东西也要留……最后，所有没被关联到的东西就是垃圾，可以扔了。

**原理详解**：

**哪些对象可以作为 GC Roots？**
1. **虚拟机栈中引用的对象**（局部变量表中的引用）
2. **方法区中静态属性引用的对象**（`static` 变量）
3. **方法区中常量引用的对象**（`static final` 常量）
4. **本地方法栈中 JNI 引用的对象**（Native 方法）
5. **被 synchronized 持有的对象**

**两种判断算法对比**：

| 算法 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| 引用计数法 | 每个对象维护一个引用计数器 | 简单高效 | ⚡**无法解决循环引用** |
| **可达性分析** | 从 GC Roots 沿引用链遍历 | 能处理循环引用 | 需要 STW（Stop The World） |

> Java 使用的是可达性分析，Python 用引用计数 + 循环检测。

**🎤 面试这样答**：
> "Java 用可达性分析算法判断对象是否存活。从 GC Roots 出发，沿着引用链遍历，不可达的对象就是垃圾。GC Roots 包括虚拟机栈中的局部变量、方法区中的静态变量和常量、本地方法栈中的 JNI 引用等。没有用引用计数法是因为它无法解决循环引用问题。另外，对象被判定不可达后还有一次自救机会——如果重写了 finalize() 且未被调用过，会被放入 F-Queue 执行 finalize()，但不推荐依赖这个机制。"

---

### 5. 垃圾回收算法有哪些？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：三种基础算法——标记-清除、标记-复制、标记-整理，实际收集器多采用分代组合策略。

**通俗理解**：

你家仓库堆满了东西，要清理垃圾：
- **标记-清除** = 先在垃圾上贴标签，然后把贴了标签的扔掉。简单粗暴，但扔完后仓库里东一个空位西一个空位（**内存碎片**）
- **标记-复制** = 把仓库一分为二，把有用的东西搬到另一半，然后把原来那半全部清空。整齐但**浪费一半空间**
- **标记-整理** = 先贴标签，然后把有用的东西全部推到仓库一头，再清理尾部。不浪费空间但**搬东西慢**

**原理详解**：

| 算法 | 过程 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| **标记-清除** | 标记存活对象 → 清除未标记对象 | 简单 | 内存碎片、效率不稳定 | CMS 老年代 |
| **标记-复制** | 将存活对象复制到另一块区域 → 清空原区域 | 无碎片、效率高 | ⚡**浪费 50% 空间** | **新生代**（存活率低） |
| **标记-整理** | 标记存活对象 → 向一端移动 → 清理边界外 | 无碎片、不浪费空间 | 移动对象开销大 | **老年代**（存活率高） |

**分代收集策略**：
- **新生代**：对象存活率低（⚡**约 98% 会死**），用**复制算法**，Eden:S0:S1 = 8:1:1，只浪费 10% 空间
- **老年代**：对象存活率高，用**标记-清除**或**标记-整理**

**🎤 面试这样答**：
> "垃圾回收有三种基础算法。标记-清除最简单但会产生内存碎片；标记-复制没有碎片但浪费一半空间，适合新生代因为大部分对象朝生夕死；标记-整理不浪费空间也没碎片，但移动对象开销大，适合老年代。实际的收集器采用分代收集策略，新生代用复制算法，老年代用标记-清除或标记-整理。"

---

### 6. 常见的垃圾收集器有哪些？CMS 和 G1 的区别？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：常见收集器有 Serial、Parallel、CMS、G1、ZGC。CMS 追求最短停顿时间但有碎片问题，G1 兼顾吞吐量和停顿时间且可预测停顿。

**通俗理解**：

垃圾收集器就像不同的"保洁公司"：
- **Serial** = 一个人打扫，打扫时所有人都得出去等着（STW）。适合小房间（小堆）
- **Parallel** = 一群人同时打扫，速度快但大家还是得出去等。追求**吞吐量**
- **CMS** = 保洁边打扫你边工作，尽量不打扰你（**低停顿**），但地上会留碎屑（内存碎片）
- **G1** = 把房间分成很多小格子（Region），哪个格子垃圾最多先打扫哪个，还能**预估打扫时间**
- **ZGC** = 黑科技保洁，几乎不用你停下来，停顿时间 ⚡**< 1ms**

**原理详解**：

| 收集器 | 作用区域 | 算法 | 线程 | 特点 | 适用场景 |
|--------|----------|------|------|------|----------|
| **Serial** | 新生代 | 复制 | 单线程 | 简单高效 | 客户端模式、小堆 |
| **Serial Old** | 老年代 | 标记-整理 | 单线程 | Serial 的老年代版本 | 客户端模式 |
| **Parallel Scavenge** | 新生代 | 复制 | 多线程 | 追求高吞吐量 | 后台计算型任务 |
| **Parallel Old** | 老年代 | 标记-整理 | 多线程 | 配合 Parallel Scavenge | 后台计算型任务 |
| **CMS** | 老年代 | 标记-清除 | 并发 | ⚡低停顿，有碎片 | JDK 8 默认老年代 |
| **G1** | 整堆（Region） | 复制+标记-整理 | 并发 | ⚡可预测停顿 | ⚡**JDK 9+ 默认** |
| **ZGC** | 整堆 | 着色指针+读屏障 | 并发 | 停顿 < 1ms | 超大堆、低延迟 |

**CMS 的四个阶段**：
1. **初始标记**（STW）：标记 GC Roots 直接关联的对象，⚡很快
2. **并发标记**：与用户线程并发，遍历对象图
3. **重新标记**（STW）：修正并发标记期间变动的对象
4. **并发清除**：与用户线程并发，清除垃圾

**G1 的核心设计**：
- 将堆划分为大小相等的 **Region**（⚡默认 **2048** 个），每个 Region 可以是 Eden/Survivor/Old/Humongous
- 维护一个**优先级列表**，优先回收垃圾最多的 Region（Garbage First 名字由来）
- 通过 `-XX:MaxGCPauseMillis`（默认 ⚡**200ms**）设置期望停顿时间

**🎤 面试这样答**：
> "CMS 是老年代收集器，用标记-清除算法，分四个阶段，其中并发标记和并发清除与用户线程并行，所以停顿时间短。但缺点是会产生内存碎片，而且并发阶段占用 CPU 资源。G1 是 JDK 9 之后的默认收集器，把堆分成多个 Region，优先回收垃圾最多的 Region，可以通过参数设置期望停顿时间。G1 整体用标记-整理，Region 之间用复制算法，不会产生碎片。对于大堆和低延迟场景，JDK 11+ 可以考虑 ZGC，停顿时间在 1ms 以内。"

---

### 7. Minor GC、Major GC、Full GC 的区别？

> ⭐⭐⭐ 常问 | 难度：⭐⭐

**回答**：

| GC 类型 | 回收区域 | 触发条件 | 特点 |
|---------|----------|----------|------|
| **Minor GC** | 新生代 | Eden 区满 | 频繁、速度快（⚡通常 **几ms ~ 几十ms**） |
| **Major GC** | 老年代 | 老年代空间不足 | 比 Minor GC 慢 ⚡**10 倍以上** |
| **Full GC** | **整个堆 + 方法区** | 老年代不足、方法区不足、`System.gc()`、CMS 并发失败等 | 最慢，应尽量避免 |

**触发 Full GC 的常见原因**：
1. 老年代空间不足
2. 方法区（元空间）不足
3. 调用 `System.gc()`（建议用 `-XX:+DisableExplicitGC` 禁用）
4. CMS 的 **Concurrent Mode Failure**（并发清理时老年代空间不够，退化为 Serial Old）
5. 晋升失败：Minor GC 后存活对象放不进老年代

---

### 8. 强引用、软引用、弱引用、虚引用的区别？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：四种引用强度递减，决定了对象在 GC 时的存活优先级。

**通俗理解**：

把对象想象成你手里抓着的气球：
- **强引用** = 用铁链拴着，刮台风也不会飞走。只要引用在，GC 绝不回收，宁可 OOM
- **软引用** = 用绳子牵着，风大了（内存不够）就放手。适合做**缓存**
- **弱引用** = 用棉线牵着，只要有风（GC 一来）就断了。`WeakHashMap` 用的就是这个
- **虚引用** = 根本没牵，气球已经飞了，你只是收到一个"气球飞走了"的通知。用于跟踪对象被回收的时机

**原理详解**：

| 引用类型 | 类 | GC 回收时机 | 用途 |
|----------|-----|------------|------|
| **强引用** | 直接赋值 `Object o = new Object()` | 引用存在就⚡**永不回收** | 普通对象引用 |
| **软引用** | `SoftReference<T>` | ⚡**内存不足时**回收 | 缓存（如图片缓存） |
| **弱引用** | `WeakReference<T>` | ⚡**下次 GC 时**必定回收 | `WeakHashMap`、`ThreadLocal` |
| **虚引用** | `PhantomReference<T>` | 随时可能回收，无法通过它获取对象 | 跟踪回收时机、堆外内存管理 |

```java
// 软引用：内存不够时才回收
SoftReference<byte[]> soft = new SoftReference<>(new byte[1024 * 1024]);
System.out.println(soft.get());  // 内存充足时能拿到

// 弱引用：下次 GC 就回收
WeakReference<Object> weak = new WeakReference<>(new Object());
System.gc();
System.out.println(weak.get());  // null —— 已被回收
```

**🎤 面试这样答**：
> "Java 有四种引用类型，强度依次递减。强引用就是普通赋值，GC 不会回收；软引用在内存不足时回收，适合做缓存；弱引用在下次 GC 时就会被回收，ThreadLocal 的 Entry 就用了弱引用防止内存泄漏；虚引用无法获取对象，主要配合 ReferenceQueue 跟踪对象回收时机，NIO 的 DirectByteBuffer 就用虚引用管理堆外内存。"

---

## 三、类加载

### 9. 类加载过程是怎样的？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：类加载分为加载、验证、准备、解析、初始化五个阶段。

**通俗理解**：

把类加载想象成"新员工入职流程"：
1. **加载** = HR 收到简历（读取 .class 文件字节流，生成 Class 对象）
2. **验证** = 背景调查（检查字节码格式是否合法，防止恶意代码）
3. **准备** = 分配工位（为 static 变量分配内存并赋**零值**，不是代码中的初始值！）
4. **解析** = 确认组织关系（把符号引用替换为直接引用）
5. **初始化** = 正式上班（执行 `<clinit>` 方法，赋真正的初始值、执行 static 代码块）

**原理详解**：

```java
public class MyClass {
    // 准备阶段：value = 0（零值）
    // 初始化阶段：value = 123（真正赋值）
    private static int value = 123;

    // 准备阶段：CONST = 123（final 常量在准备阶段就赋真值！）
    private static final int CONST = 123;
}
```

**触发初始化的 6 种情况**（主动引用）：
1. `new`、`getstatic`、`putstatic`、`invokestatic` 指令
2. 反射调用（`Class.forName()`）
3. 初始化子类时，父类未初始化则先初始化父类
4. 主类（包含 `main()` 的类）
5. JDK 7 的 `MethodHandle`
6. JDK 8 的接口默认方法

**🎤 面试这样答**：
> "类加载分五个阶段：加载、验证、准备、解析、初始化。重点注意准备阶段是给 static 变量赋零值而不是初始值，真正赋值在初始化阶段。但 static final 的编译期常量在准备阶段就会赋真值。初始化是执行 clinit 方法，包括 static 变量赋值和 static 代码块，JVM 会保证 clinit 方法的线程安全。"

---

### 10. 什么是双亲委派模型？为什么需要它？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：类加载时先委托父加载器加载，父加载器加载不了再自己加载。保证核心类库的安全性和唯一性。

**通俗理解**：

双亲委派就像"逐级请示"制度：
- 你（应用类加载器）接到一个任务，不自己干，先交给领导（扩展类加载器）
- 领导也不自己干，再交给大领导（启动类加载器）
- 大领导能干就干了（加载 `java.lang.*` 等核心类），干不了再退回给领导
- 领导能干就干，干不了再退回给你
- 最后你自己来加载

**原理详解**：

```
        ┌─────────────────────┐
        │  Bootstrap ClassLoader │  ← 加载 rt.jar（java.lang.* 等）
        │  （启动类加载器，C++ 实现） │
        └──────────┬──────────┘
                   ↑ 委托
        ┌──────────┴──────────┐
        │  Extension ClassLoader │  ← 加载 ext 目录下的 jar
        │  （扩展类加载器）        │
        └──────────┬──────────┘
                   ↑ 委托
        ┌──────────┴──────────┐
        │ Application ClassLoader│  ← 加载 classpath 下的类
        │  （应用类加载器）        │
        └──────────┬──────────┘
                   ↑ 委托
        ┌──────────┴──────────┐
        │  Custom ClassLoader    │  ← 自定义类加载器
        └─────────────────────┘
```

**为什么需要双亲委派？**
1. **安全性**：防止用户自定义一个 `java.lang.String` 来替换核心类
2. **唯一性**：保证同一个类只被加载一次，避免出现多个不同的 String 类

**破坏双亲委派的场景**：
- **SPI 机制**（如 JDBC）：核心接口在 rt.jar，实现在第三方 jar，需要用 **线程上下文类加载器（Thread Context ClassLoader）** 反向委托
- **热部署/热替换**：如 Tomcat 的 WebAppClassLoader，每个 Web 应用独立加载，优先加载自己目录下的类
- **OSGi 模块化**：网状委托，不是单纯的树形结构

**🎤 面试这样答**：
> "双亲委派模型是指类加载时先委托父加载器加载，加载不了再自己加载。三层加载器分别是：启动类加载器加载核心类库，扩展类加载器加载 ext 目录，应用类加载器加载 classpath。这样设计的好处是保证核心类的安全性和唯一性，比如自定义一个 java.lang.String 不会被加载。但也有破坏双亲委派的场景，比如 JDBC 的 SPI 机制通过线程上下文类加载器实现反向委托，Tomcat 为了 Web 应用隔离也打破了双亲委派。"

---

## 四、实战调优

### 11. 常用的 JVM 调优参数有哪些？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：JVM 调优参数主要分为内存设置、GC 收集器选择、GC 日志输出三大类。

**通俗理解**：

JVM 调优就像给汽车调发动机参数——油箱多大（堆内存）、用什么型号的发动机（GC 收集器）、要不要装行车记录仪（GC 日志）。参数调得好，车跑得又快又稳；调不好，要么油箱太小半路抛锚（OOM），要么发动机老熄火（频繁 Full GC）。

**原理详解**：

**① 内存相关参数**：

| 参数 | 含义 | 推荐值 |
|------|------|--------|
| `-Xms` | 堆初始大小 | ⚡**与 -Xmx 设为相同值**，避免动态扩缩容 |
| `-Xmx` | 堆最大大小 | 物理内存的 ⚡**60%~70%** |
| `-Xmn` | 新生代大小 | 堆的 ⚡**1/3 ~ 1/4** |
| `-Xss` | 每个线程的栈大小 | 默认 ⚡**1MB**（HotSpot 64 位） |
| `-XX:MetaspaceSize` | 元空间初始大小 | 建议设为 ⚡**256MB** |
| `-XX:MaxMetaspaceSize` | 元空间最大大小 | 建议设为 ⚡**256MB** |

**② GC 收集器选择**：

| 参数 | 含义 |
|------|------|
| `-XX:+UseSerialGC` | 使用 Serial + Serial Old |
| `-XX:+UseParallelGC` | 使用 Parallel Scavenge + Parallel Old（⚡**JDK 8 默认**） |
| `-XX:+UseConcMarkSweepGC` | 使用 ParNew + CMS |
| `-XX:+UseG1GC` | 使用 G1（⚡**JDK 9+ 默认**） |
| `-XX:+UseZGC` | 使用 ZGC（JDK 11+） |

**③ GC 日志参数**（JDK 8）：

```bash
# JDK 8 GC 日志
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:/path/to/gc.log

# JDK 9+ 统一日志框架
-Xlog:gc*:file=/path/to/gc.log:time,uptime,level,tags
```

**④ 常用调优组合示例**：

```bash
# 典型的线上 JDK 8 + G1 配置
java -Xms4g -Xmx4g -Xmn2g \
     -XX:+UseG1GC \
     -XX:MaxGCPauseMillis=200 \
     -XX:MetaspaceSize=256m \
     -XX:MaxMetaspaceSize=256m \
     -XX:+PrintGCDetails \
     -XX:+PrintGCDateStamps \
     -Xloggc:/opt/logs/gc.log \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=/opt/logs/heapdump.hprof \
     -jar app.jar
```

**🎤 面试这样答**：
> "JVM 调优参数主要分三类。内存方面，-Xms 和 -Xmx 建议设成一样避免动态扩缩容，一般设为物理内存的 60%~70%，-Xss 默认 1MB。GC 方面，JDK 8 默认 Parallel，JDK 9+ 默认 G1，G1 可以通过 MaxGCPauseMillis 设置期望停顿时间。日志方面，一定要开启 GC 日志和 HeapDumpOnOutOfMemoryError，方便线上排查问题。"

---

### 12. 线上出现 OOM，如何排查？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐⭐

**一句话回答**：先保留现场（堆转储文件），再用工具分析内存中哪些对象占用最多，定位到代码中的内存泄漏点。

**通俗理解**：

线上 OOM 就像家里水管爆了——你不能光把水擦干（重启服务），得先拍照留证据（dump 堆快照），然后找水管工（MAT 工具）分析是哪根管子漏的（哪个对象占了太多内存），最后修管子（修代码）。

**原理详解**：

**排查步骤**：

**第一步：保留现场**

```bash
# 方式一：提前配置，OOM 时自动 dump（推荐）
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/opt/logs/heapdump.hprof

# 方式二：手动 dump（进程还活着时）
jmap -dump:format=b,file=heapdump.hprof <pid>
```

**第二步：分析堆转储文件**

常用工具：
| 工具 | 特点 |
|------|------|
| **MAT**（Eclipse Memory Analyzer） | 最强大，支持 Leak Suspects 自动分析 |
| **VisualVM** | JDK 自带，轻量级 |
| **jhat** | 命令行工具，适合服务器上快速查看 |
| **Arthas** | 阿里开源，在线诊断，不用重启 |

**第三步：定位问题**

MAT 打开 dump 文件后重点看：
1. **Leak Suspects Report**：自动分析可疑的内存泄漏点
2. **Dominator Tree**：按对象占用内存大小排序，找到"大胖子"
3. **Histogram**：按类统计对象数量和大小，看哪个类的实例最多

**常见 OOM 原因及解决方案**：

| OOM 类型 | 常见原因 | 解决方案 |
|----------|----------|----------|
| `Java heap space` | 内存泄漏、大对象、堆太小 | 分析 dump，修复泄漏或加大堆 |
| `Metaspace` | 动态生成类过多（CGLib、反射） | 加大 MetaspaceSize 或排查类加载 |
| `GC overhead limit exceeded` | GC 回收不了足够内存（⚡**98% 时间在 GC，回收不到 2% 内存**） | 同 heap space |
| `unable to create new native thread` | 线程数过多 | 减小 -Xss 或限制线程池大小 |
| `Direct buffer memory` | NIO 堆外内存溢出 | 加大 `-XX:MaxDirectMemorySize` |

**🎤 面试这样答**：
> "线上 OOM 排查我一般分三步。第一步保留现场，提前配置 HeapDumpOnOutOfMemoryError 参数，OOM 时自动生成堆转储文件。第二步用 MAT 分析 dump 文件，重点看 Leak Suspects 报告和 Dominator Tree，找到占用内存最大的对象。第三步根据对象的引用链定位到代码，常见原因有集合只进不出导致内存泄漏、大查询没分页、缓存没有淘汰策略等。我之前处理过一个案例，是 ThreadLocal 没有 remove 导致的内存泄漏，在 MAT 中看到大量 ThreadLocalMap$Entry 对象。"

---

### 13. 对象的创建过程是怎样的？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：在 HotSpot 中，`new` 一个对象的完整过程分为 5 步：

1. **类加载检查**：检查该类是否已被加载、解析、初始化，没有则先触发类加载
2. **分配内存**：在堆中为对象分配空间，两种方式：
   - **指针碰撞（Bump the Pointer）**：堆内存规整时使用，移动分界指针即可（Serial、ParNew 等带压缩的收集器）
   - **空闲列表（Free List）**：堆内存不规整时使用，从列表中找到足够大的空闲块（CMS 等标记-清除收集器）
3. **初始化零值**：将分配到的内存空间初始化为零值（`int` → 0，`boolean` → false，引用 → null），这就是为什么字段不赋值也有默认值
4. **设置对象头**：填充 Mark Word（哈希码、GC 年龄、锁标志等）和类型指针
5. **执行 `<init>` 方法**：执行构造方法，按程序员的意愿进行初始化

**线程安全问题**：多线程同时分配内存时，有两种解决方案：

| 方案 | 原理 |
|------|------|
| **CAS + 失败重试** | 乐观锁，分配时用 CAS 保证原子性 |
| **TLAB**（Thread Local Allocation Buffer） | 每个线程预先分配一小块私有内存（⚡**默认 Eden 的 1%**），在自己的 TLAB 上分配，用完再同步申请新的 |

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | JVM 运行时数据区有哪些 |
| ⭐⭐⭐⭐⭐ | 如何判断对象是否可以被回收（GC Roots） |
| ⭐⭐⭐⭐⭐ | 垃圾回收算法有哪些 |
| ⭐⭐⭐⭐⭐ | 常见的垃圾收集器，CMS 和 G1 的区别 |
| ⭐⭐⭐⭐⭐ | 双亲委派模型 |
| ⭐⭐⭐⭐ | 堆内存的分代模型 |
| ⭐⭐⭐⭐ | 强引用、软引用、弱引用、虚引用的区别 |
| ⭐⭐⭐⭐ | 类加载过程 |
| ⭐⭐⭐⭐ | 常用的 JVM 调优参数 |
| ⭐⭐⭐⭐ | 线上 OOM 如何排查 |
| ⭐⭐⭐ | 对象在内存中的布局 |
| ⭐⭐⭐ | Minor GC、Major GC、Full GC 的区别 |
| ⭐⭐⭐ | 对象的创建过程 |

