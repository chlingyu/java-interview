# 18 - ElasticSearch

> 覆盖 ES 核心知识：倒排索引原理、基本概念、查询方式、深分页、集群架构等高频面试考点。倒排索引几乎每场必问。

---

## 一、基础

### 1. 什么是 ElasticSearch？为什么用它？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐

**一句话回答**：ElasticSearch（ES）是一个基于 Lucene 的分布式全文搜索引擎，支持海量数据的近实时搜索和分析。MySQL 的 LIKE 查询在大数据量下性能极差，ES 通过倒排索引实现毫秒级搜索。

**通俗理解**：

- **MySQL 查数据** = 你在一本 500 页的书里找"分布式"这个词，只能从第 1 页翻到第 500 页，逐页查找 → 全表扫描，慢
- **ES 查数据** = 你翻到书最后的"索引页"，直接查到"分布式"出现在第 32、78、156 页，一步到位 → 倒排索引，快

**回到技术**："索引页"就是 ES 的倒排索引，它预先把每个词出现在哪些文档中记录好了，查询时直接定位，不需要遍历所有数据。

| 对比项 | MySQL | ElasticSearch |
|--------|-------|---------------|
| 擅长场景 | 事务、精确查询、关联查询 | ⚡**全文搜索、模糊匹配、聚合分析** |
| 查询方式 | SQL | DSL（JSON 格式的查询语法） |
| 数据量 | 单表百万级以上就慢 | ⚡**亿级数据毫秒级响应** |
| 实时性 | 实时 | ⚡**近实时**（默认 1 秒刷新间隔） |

> **实际应用**：商品搜索、日志分析（ELK 栈）、站内搜索、数据监控。ES 通常和 MySQL 配合使用——MySQL 存主数据，ES 存搜索数据，通过 Canal 或 MQ 同步。

**🎤 面试这样答**：
> "ElasticSearch 是基于 Lucene 的分布式全文搜索引擎，核心优势是通过倒排索引实现亿级数据的毫秒级搜索。MySQL 的 LIKE 查询在大数据量下性能很差，ES 预先把每个词出现在哪些文档中建好索引，查询时直接定位。实际项目中 ES 和 MySQL 配合使用，MySQL 存主数据保证事务，ES 存搜索数据提供检索能力，通过 Canal 或 MQ 做数据同步。"

---

### 2. 什么是倒排索引？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：倒排索引是 ES 实现快速搜索的核心数据结构，它记录的是"每个词出现在哪些文档中"，和传统的"每个文档包含哪些词"正好相反。

**通俗理解**：

假设你是图书管理员，有 3 本书：
- 文档 1：「Java 并发编程」
- 文档 2：「Java 虚拟机」
- 文档 3：「并发与高可用」

**正排索引**（传统方式）= 按书编号查内容：
```
文档 1 → Java, 并发, 编程
文档 2 → Java, 虚拟机
文档 3 → 并发, 高可用
```

**倒排索引** = 按关键词查书编号：
```
Java   → 文档 1, 文档 2
并发   → 文档 1, 文档 3
编程   → 文档 1
虚拟机 → 文档 2
高可用 → 文档 3
```

**回到技术**："按关键词查书编号"就是倒排索引的核心思想。当你搜索"Java"时，ES 直接从倒排索引中查到它出现在文档 1 和文档 2，不需要遍历所有文档。

**倒排索引的组成**：

| 组成部分 | 说明 |
|---------|------|
| **Term（词项）** | 文本经过分词后的每个词，如"Java"、"并发" |
| **Term Dictionary（词项字典）** | 所有词项的有序集合，用于快速查找 |
| **Posting List（倒排列表）** | 每个词项对应的文档 ID 列表，还包含词频、位置等信息 |

> **分词器的作用**：文档写入 ES 时，先经过**分词器（Analyzer）**把文本拆成一个个词项。中文分词常用 ⚡**IK 分词器**（支持 ik_smart 粗粒度和 ik_max_word 细粒度两种模式）。

**🎤 面试这样答**：
> "倒排索引是 ES 的核心数据结构，和传统的正排索引相反。正排索引是文档到词的映射，倒排索引是词到文档的映射。写入数据时，ES 先用分词器把文本拆成词项，然后建立每个词项到文档 ID 列表的映射。查询时直接通过词项定位到文档，不需要遍历，所以搜索速度非常快。中文场景一般用 IK 分词器。"

---

## 二、核心概念

### 3. ES 的基本概念？和 MySQL 怎么对应？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐

**一句话回答**：ES 的 Index 对应 MySQL 的表，Document 对应一行数据，Field 对应列，Mapping 对应表结构定义。

简单说，ES 的数据组织方式和 MySQL 类似，只是叫法不同。你把 Index 当成表、Document 当成行来理解就行。

| ES 概念 | MySQL 对应 | 说明 |
|---------|-----------|------|
| **Index（索引）** | 表（Table） | 一类数据的集合，如 `product_index` |
| **Document（文档）** | 行（Row） | 一条数据，JSON 格式 |
| **Field（字段）** | 列（Column） | 文档中的一个属性 |
| **Mapping（映射）** | 表结构（Schema） | 定义字段类型（text、keyword、long 等） |
| **Shard（分片）** | 分表 | 一个 Index 拆成多个分片，分布在不同节点 |
| **Replica（副本）** | 从库 | 分片的副本，提供高可用和读扩展 |

> **注意**：ES 7.x 之后移除了 Type（类型）的概念，一个 Index 下只有一个默认 Type（`_doc`）。面试中如果被问到 Type，说明白这个变化就行。

---

## 三、查询

### 4. match 和 term 查询的区别？

> ⭐⭐⭐ 常问 | 难度：⭐⭐

**回答**：简单说，match 查询会先分词再匹配，适合全文搜索；term 查询不分词，做精确匹配，适合 keyword 类型字段。

| 查询方式 | 是否分词 | 适用场景 | 示例 |
|---------|---------|---------|------|
| **match** | ⚡**会分词** | 全文搜索（商品名、文章内容） | 搜"Java 编程" → 拆成"Java"和"编程"分别匹配 |
| **term** | ⚡**不分词** | 精确匹配（状态码、ID、枚举值） | 搜"PUBLISHED" → 精确匹配这个完整词 |

```json
// match 查询：会对"Java 编程"分词后匹配
{ "query": { "match": { "title": "Java 编程" } } }

// term 查询：精确匹配 status 字段
{ "query": { "term": { "status": "PUBLISHED" } } }
```

> **常见坑**：对 text 类型字段用 term 查询往往查不到结果，因为 text 字段写入时已经被分词了（"Java编程"被拆成"java"和"编程"），而 term 拿"Java编程"去精确匹配，自然匹配不上。精确匹配要用 ⚡**keyword 类型**字段。

---

### 5. ES 深分页问题怎么解决？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：ES 默认的 from + size 分页在深页时性能极差（要在每个分片上取 from+size 条数据再汇总排序），解决方案是用 scroll 或 search_after。

**通俗理解**：

你要从 10 个班级中选出全年级第 9901~10000 名的学生。from+size 的做法是让每个班都把前 10000 名报上来（10 个班 = 10 万条数据），汇总后再取最后 100 个。班级越多、页码越深，汇总的数据量越恐怖。

**回到技术**："每个班报前 10000 名"就是每个分片返回 from+size 条数据给协调节点。ES 默认限制 ⚡**from + size ≤ 10000**，超过就报错。

| 方案 | 原理 | 适用场景 |
|------|------|---------|
| **from + size** | 跳过 from 条，取 size 条 | 浅分页（前几百页） |
| **scroll** | 生成快照，用游标逐批拉取 | 大量数据导出（非实时） |
| **search_after** | 用上一页最后一条的排序值作为起点 | ⚡**实时深分页（推荐）** |

```json
// search_after 示例：用上一页最后一条的排序值翻页
{
  "size": 10,
  "sort": [{ "create_time": "desc" }, { "_id": "asc" }],
  "search_after": [1672531200000, "doc_id_xxx"]  // 上一页最后一条的排序值
}
```

> **实际开发建议**：前端分页展示用 from+size（限制最多翻 100 页），数据导出用 scroll，无限滚动/瀑布流用 search_after。

**🎤 面试这样答**：
> "ES 深分页的问题在于 from+size 方式下，每个分片都要返回 from+size 条数据给协调节点汇总，页码越深数据量越大，默认限制 from+size 不超过 10000。解决方案有三种：scroll 生成快照用游标逐批拉取，适合数据导出；search_after 用上一页最后一条的排序值作为起点往后查，适合实时深分页，是推荐方案。实际开发中前端分页用 from+size 限制页数，无限滚动用 search_after。"

---

## 四、集群

### 6. ES 集群的节点角色？写入和查询流程？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：ES 集群中节点分为 Master 节点、Data 节点和 Coordinating 节点。你可以理解为公司里有管理层（Master）、干活的员工（Data）、和前台接待（Coordinating）。

| 节点角色 | 职责 |
|---------|------|
| **Master 节点** | 管理集群元数据（索引创建/删除、分片分配），不存数据 |
| **Data 节点** | 存储数据，执行增删改查 |
| **Coordinating 节点** | 接收客户端请求，转发到对应 Data 节点，汇总结果返回 |

**写入流程**：

```
① 客户端发写入请求到任意节点（该节点成为协调节点）
② 协调节点根据文档 ID 哈希，路由到对应的主分片（Primary Shard）
③ 主分片写入成功后，同步到副本分片（Replica Shard）
④ 所有副本确认后，返回客户端成功
```

**查询流程（Query Then Fetch）**：

```
① 协调节点把查询请求发到所有相关分片（Query 阶段）
② 每个分片返回匹配的文档 ID 和排序值
③ 协调节点汇总排序，确定最终要取的文档 ID
④ 协调节点向对应分片拉取完整文档内容（Fetch 阶段）
⑤ 返回结果给客户端
```

> **为什么 ES 是近实时而不是实时？** 文档写入后先进入内存 Buffer，每隔 ⚡**1 秒**（默认 refresh_interval）刷新到文件系统缓存（Segment）才能被搜索到。这就是"近实时"的原因。

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | 什么是 ElasticSearch？为什么用它？ |
| ⭐⭐⭐⭐⭐ | 什么是倒排索引？ |
| ⭐⭐⭐⭐ | ES 的基本概念？和 MySQL 怎么对应？ |
| ⭐⭐⭐⭐ | ES 深分页问题怎么解决？ |
| ⭐⭐⭐ | match 和 term 查询的区别？ |
| ⭐⭐⭐ | ES 集群的节点角色？写入和查询流程？ |