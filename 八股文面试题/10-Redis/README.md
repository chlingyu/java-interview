# 10 - Redis

> 覆盖 Redis 核心知识：数据结构、持久化、缓存穿透/击穿/雪崩、分布式锁、缓存一致性等高频面试考点。缓存三兄弟和分布式锁是面试重灾区。

---

## 一、基础

### 1. Redis 常用的数据类型有哪些？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐

**一句话回答**：Redis 有 ⚡**5 种基础数据类型**（String、List、Hash、Set、Sorted Set）和几种特殊类型（BitMap、HyperLogLog、GEO、Stream）。

**通俗理解**：

你可以把 Redis 想象成一个超级工具箱，每种数据类型就是一种工具，解决不同的问题：

| 类型 | 通俗理解 | 典型场景 |
|------|---------|---------|
| **String** | 最简单的 key-value，就像一个变量 | 缓存、计数器、分布式锁 |
| **List** | 有序列表，像一个队列 | 消息队列、最新消息列表 |
| **Hash** | 键值对集合，像一个 Map | 存储对象（用户信息） |
| **Set** | 无序不重复集合 | 点赞、共同好友、抽奖 |
| **Sorted Set（ZSet）** | 有序不重复集合，每个元素带分数 | 排行榜、延迟队列 |

```bash
# String：缓存 + 计数器
SET user:1:name "张三"
INCR article:1:views          # 文章浏览量 +1

# Hash：存储对象
HSET user:1 name "张三" age 25

# Sorted Set：排行榜
ZADD leaderboard 100 "玩家A" 200 "玩家B"
ZREVRANGE leaderboard 0 9     # 取 Top 10
```

> **面试追问**：String 的最大值是多少？⚡**512 MB**。但实际使用中建议单个 value 不超过 ⚡**10 KB**，大 value 会阻塞 Redis。

**回到技术**："超级工具箱"就是 Redis 提供了多种数据结构，每种结构底层有不同的编码实现。比如 String 底层用 SDS（Simple Dynamic String），List 在元素少时用 listpack、多时用 quicklist，Hash 少时用 listpack、多时用 hashtable。选对数据类型能大幅提升性能。

**🎤 面试这样答**：
> "Redis 有 5 种基础数据类型：String 用于缓存和计数器；List 用于消息队列和最新列表；Hash 用于存储对象；Set 用于去重和集合运算；Sorted Set 用于排行榜。还有 BitMap、HyperLogLog、GEO 等特殊类型。选择数据类型的关键是匹配业务场景，比如排行榜用 ZSet，共同好友用 Set 的交集运算。"

---

### 2. Redis 为什么这么快？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：基于内存、单线程避免上下文切换、IO 多路复用、高效的数据结构，四个原因共同造就了 Redis 的高性能。

**通俗理解**：

把 Redis 想象成一个超级快的餐厅：
- **基于内存** = 食材全放在手边的操作台上，不用跑去仓库拿 → ⚡**内存读写比磁盘快 10 万倍**
- **单线程** = 只有一个大厨，但他手速极快，不需要和别人协调谁用哪个锅 → 没有锁竞争、没有上下文切换
- **IO 多路复用** = 大厨面前有一排取餐窗口，哪个窗口的菜好了就处理哪个，不会傻等某一个 → 一个线程同时处理大量连接
- **高效数据结构** = 厨房工具都是专门定制的，切菜、炒菜都有最趁手的工具

**回到技术**："操作台"就是内存，所有数据都在内存中操作，不需要磁盘 IO。"一个大厨"就是 Redis 的命令处理是单线程的（⚡**Redis 6.0 之后网络 IO 用了多线程，但命令执行仍然是单线程**）。"取餐窗口"就是 **epoll/kqueue** 等 IO 多路复用机制，一个线程监听多个 socket 连接。

**🎤 面试这样答**：
> "Redis 快主要有四个原因：一是所有数据都在内存中操作，内存读写速度远超磁盘；二是采用单线程模型处理命令，避免了多线程的锁竞争和上下文切换开销；三是使用 IO 多路复用技术，一个线程就能高效处理大量客户端连接；四是底层数据结构经过精心设计，比如 SDS、跳表、压缩列表等，都针对性能做了优化。需要注意的是 Redis 6.0 引入了多线程处理网络 IO，但命令执行仍然是单线程的。"

---

## 二、缓存问题

### 3. 缓存穿透、缓存击穿、缓存雪崩的区别和解决方案？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：穿透是查不存在的数据，击穿是热点 key 过期，雪崩是大量 key 同时过期。三者都会导致请求直接打到数据库。

**通俗理解**：

把 Redis 想象成一面盾牌，挡在数据库前面保护它：

- **缓存穿透** = 敌人专门攻击盾牌上没有的位置（查一个根本不存在的数据），每次都穿过盾牌直接打到你身上 → 数据库被恶意请求打垮
- **缓存击穿** = 盾牌上有一个点被反复攻击，突然这个点裂开了（热点 key 过期），所有攻击瞬间集中打到你身上 → 数据库被瞬时高并发压垮
- **缓存雪崩** = 盾牌突然整个碎了（大量 key 同时过期或 Redis 宕机），所有攻击全部打到你身上 → 数据库被全面压垮

**回到技术**："盾牌上没有的位置"就是缓存和数据库中都不存在的数据，每次查询都穿透缓存直达数据库。"一个点裂开"就是某个被高并发访问的热点 key 恰好过期。"盾牌碎了"就是大批 key 在同一时间过期，或者 Redis 服务本身挂了。

**原理详解**：

| 问题 | 本质 | 解决方案 |
|------|------|---------|
| **缓存穿透** | 查询⚡**不存在**的数据 | ① 缓存空值（设短过期时间）② ⚡**布隆过滤器**拦截 |
| **缓存击穿** | ⚡**热点 key** 过期 | ① 热点 key 永不过期 ② ⚡**互斥锁**，只让一个线程重建缓存 |
| **缓存雪崩** | ⚡**大量 key 同时**过期 | ① 过期时间加随机值，打散过期时间 ② Redis 集群高可用 |

**布隆过滤器防穿透**：

```
请求进来 → 先问布隆过滤器"这个 key 存在吗？"
  - 布隆说"不存在" → 一定不存在，直接返回，不查数据库
  - 布隆说"存在"   → 可能存在（有误判），继续查缓存和数据库
```

> 布隆过滤器的特点：说"不存在"⚡**一定不存在**，说"存在"⚡**可能误判**。误判率可以通过调整位数组大小和哈希函数个数来控制。

**🎤 面试这样答**：
> "缓存穿透是查询一个缓存和数据库都不存在的数据，解决方案是缓存空值或用布隆过滤器提前拦截。缓存击穿是热点 key 突然过期导致大量请求打到数据库，解决方案是热点 key 不设过期时间或用互斥锁保证只有一个线程重建缓存。缓存雪崩是大量 key 同时过期，解决方案是给过期时间加随机值打散，同时做好 Redis 的高可用部署。"

---

## 三、持久化

### 4. Redis 的持久化方式？RDB 和 AOF 的区别？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：Redis 有两种持久化方式——RDB（快照）和 AOF（追加日志）。RDB 是定时拍快照，恢复快但可能丢数据；AOF 是记录每条写命令，数据更安全但文件更大。

**通俗理解**：

把 Redis 的数据想象成你在画板上画的画：
- **RDB** = 每隔一段时间给画板拍一张照片。恢复时直接看照片就行，很快。但如果拍完照之后你又画了很多，突然停电了，照片之后画的内容就丢了
- **AOF** = 你每画一笔就在旁边的本子上记一条"在 x,y 位置画了一条线"。恢复时按本子上的记录重新画一遍，慢一点但几乎不丢东西

**回到技术**："拍照片"就是 RDB 把某一时刻的全部数据生成一个二进制快照文件（dump.rdb）。"记笔记"就是 AOF 把每条写命令追加到日志文件（appendonly.aof）中，重启时重放这些命令恢复数据。

**原理详解**：

| 对比项 | RDB | AOF |
|--------|-----|-----|
| 持久化方式 | 定时生成数据⚡**快照** | 记录每条⚡**写命令** |
| 文件大小 | 小（二进制压缩） | 大（文本命令日志） |
| 恢复速度 | ⚡**快**（直接加载快照） | 慢（要重放所有命令） |
| 数据安全性 | 可能丢失最后一次快照后的数据 | 最多丢 ⚡**1 秒**数据（everysec 策略） |
| 对性能的影响 | fork 子进程时可能短暂阻塞 | 追加写入，影响较小 |

**AOF 的三种刷盘策略**：

| 策略 | 说明 | 数据安全 |
|------|------|---------|
| **always** | 每条命令都刷盘 | 最安全，但⚡**性能最差** |
| **everysec** | ⚡**每秒刷一次**（默认推荐） | 最多丢 1 秒数据，性能和安全的平衡 |
| **no** | 交给操作系统决定何时刷盘 | 性能最好，但可能丢较多数据 |

> **实际生产怎么选？** 推荐 ⚡**RDB + AOF 混合持久化**（Redis 4.0+）。AOF 重写时先写入 RDB 快照，再追加增量 AOF 命令，兼顾恢复速度和数据安全。

**🎤 面试这样答**：
> "Redis 有 RDB 和 AOF 两种持久化方式。RDB 是定时生成数据快照，文件小、恢复快，但可能丢失最后一次快照后的数据。AOF 是记录每条写命令，默认每秒刷盘一次，最多丢 1 秒数据，但文件大、恢复慢。生产环境推荐用 Redis 4.0 之后的混合持久化，AOF 重写时先写 RDB 快照再追加增量命令，兼顾了恢复速度和数据安全。"

---

## 四、内存管理

### 5. Redis 的过期删除策略和内存淘汰策略？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：过期删除用的是惰性删除 + 定期删除；内存不够时触发内存淘汰策略，常用的是 allkeys-lru。

**通俗理解**：

把 Redis 想象成一个冰箱：
- **惰性删除** = 你拿东西的时候才看一眼保质期，过期了就扔掉。不拿就不检查
- **定期删除** = 每隔一段时间打开冰箱随机翻几样东西，过期的扔掉
- **内存淘汰** = 冰箱满了放不下新东西，按规则扔掉一些旧的腾出空间

**回到技术**："拿东西时检查"就是访问 key 时才判断是否过期。"随机翻几样"就是 Redis 每隔 ⚡**100ms** 随机抽取一批设了过期时间的 key 检查。两种策略配合使用，既不会太浪费 CPU，也不会让过期 key 长期占用内存。

**过期删除策略**：

| 策略 | 说明 | 优缺点 |
|------|------|--------|
| **惰性删除** | 访问 key 时才检查是否过期 | CPU 友好，但过期 key 可能长期不被访问，⚡**浪费内存** |
| **定期删除** | 每 100ms 随机抽查一批 key | 折中方案，但可能有漏网之鱼 |

**内存淘汰策略**（当内存达到 `maxmemory` 时触发）：

| 策略 | 说明 |
|------|------|
| **noeviction** | ⚡**默认**，不淘汰，内存满了直接报错 |
| **allkeys-lru** | ⚡**最常用**，从所有 key 中淘汰最近最少使用的 |
| **volatile-lru** | 从设了过期时间的 key 中淘汰最近最少使用的 |
| **allkeys-random** | 从所有 key 中随机淘汰 |
| **volatile-ttl** | 从设了过期时间的 key 中淘汰即将过期的 |
| **allkeys-lfu** | 从所有 key 中淘汰使用频率最低的（Redis 4.0+） |

> **生产环境推荐**：⚡**allkeys-lru**，淘汰最近最少使用的 key，适合缓存场景。

**🎤 面试这样答**：
> "Redis 过期删除用的是惰性删除加定期删除两种策略配合。惰性删除是访问 key 时才检查过期，定期删除是每 100ms 随机抽查一批 key。当内存达到上限时触发内存淘汰策略，生产环境推荐 allkeys-lru，淘汰最近最少使用的 key。"

---

## 五、分布式锁

### 6. Redis 分布式锁怎么实现？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：用 `SET key value NX EX` 命令加锁，保证原子性；释放锁时用 Lua 脚本保证"判断 + 删除"的原子性。生产环境推荐用 Redisson 框架。

**通俗理解**：

分布式锁就像公共厕所的门锁：
- **加锁** = 进去后把门锁上，门上贴个纸条写"我是张三"（value 存唯一标识）
- **设过期时间** = 防止你在里面晕倒了，门永远锁着别人进不去（⚡**避免死锁**）
- **释放锁** = 出来时先看纸条是不是自己的名字，是才开门。不能把别人锁的门打开（⚡**只能释放自己的锁**）

**回到技术**："贴纸条"就是 SET 命令的 NX 参数（Not Exists，key 不存在才能设置成功）。"唯一标识"通常用 UUID + 线程 ID。"设过期时间"就是 EX 参数，防止持有锁的进程崩溃导致锁永远不释放。

**原理详解**：

**加锁**：

```bash
# 原子操作：key 不存在才设置，同时设置过期时间 30 秒
SET lock_key unique_value NX EX 30
```

**释放锁**（必须用 Lua 脚本保证原子性）：

```lua
-- 先判断是不是自己的锁，是才删除
if redis.call("GET", KEYS[1]) == ARGV[1] then
    return redis.call("DEL", KEYS[1])
else
    return 0
end
```

> **为什么释放锁要用 Lua 脚本？** 因为"判断是不是自己的锁"和"删除锁"是两步操作，如果不用 Lua 保证原子性，可能在判断完之后、删除之前，锁恰好过期被别人拿到了，你就把别人的锁删了。

**分布式锁的三个核心问题**：

| 问题 | 说明 | 解决方案 |
|------|------|---------|
| **锁过期但业务没执行完** | 锁到期自动释放，别人拿到锁，两个线程同时执行 | ⚡**看门狗机制**（Redisson 自动续期） |
| **误删别人的锁** | A 的锁过期后 B 拿到锁，A 执行完把 B 的锁删了 | value 存唯一标识 + Lua 脚本判断 |
| **Redis 主从切换丢锁** | 主节点加锁后还没同步到从节点就挂了，从节点升主后锁丢失 | ⚡**RedLock 算法**（向多个独立 Redis 实例加锁） |

> **生产环境直接用 Redisson**，它封装了加锁、释放锁、看门狗续期、可重入等所有细节，不需要自己写 Lua 脚本。

**🎤 面试这样答**：
> "Redis 分布式锁用 SET NX EX 命令原子性地加锁，value 存唯一标识防止误删。释放锁时用 Lua 脚本保证判断和删除的原子性。主要问题有三个：锁过期业务没执行完，Redisson 的看门狗机制会自动续期；误删别人的锁，通过唯一标识加 Lua 脚本解决；主从切换丢锁，可以用 RedLock 算法。生产环境推荐直接用 Redisson。"

---

## 六、缓存一致性

### 7. 如何保证缓存和数据库的一致性？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：推荐 **Cache Aside 模式**——读时先查缓存，缓存没有再查数据库并回填缓存；写时先更新数据库，再删除缓存。

**通俗理解**：

把缓存想象成你手机上的备忘录，数据库是公司的正式档案：
- **读数据** = 先看备忘录（缓存），有就直接用；没有就去翻档案（数据库），翻到后顺手抄一份到备忘录
- **写数据** = 先改档案（数据库），然后把备忘录上的旧内容撕掉（删缓存）。下次要用的时候再从档案重新抄一份

**回到技术**："撕掉备忘录"就是删除缓存而不是更新缓存。为什么删而不是更新？因为更新缓存在并发场景下容易出现数据不一致——两个线程同时更新，后更新数据库的可能先更新了缓存，导致缓存里是旧值。

**原理详解**：

**为什么是"先更新数据库，再删缓存"？**

| 方案 | 问题 |
|------|------|
| 先删缓存，再更新数据库 | ⚡**不推荐**。删完缓存、还没更新数据库时，另一个请求读到旧数据写回缓存，导致不一致 |
| 先更新数据库，再删缓存 | ⚡**推荐**。极端情况下仍有短暂不一致，但概率极低 |

**如果删缓存失败了怎么办？**

- **重试机制**：删除失败后发送到⚡**消息队列**，由消费者异步重试删除
- **延迟双删**：先删缓存 → 更新数据库 → 延迟一段时间再删一次缓存（兜底）
- **订阅 binlog**：用 Canal 等工具监听 MySQL 的 binlog，数据变更时自动删除对应缓存

**🎤 面试这样答**：
> "保证缓存一致性推荐用 Cache Aside 模式：读时先查缓存，miss 了再查数据库并回填；写时先更新数据库再删除缓存。选择删除而不是更新缓存，是为了避免并发更新导致的数据不一致。如果删缓存失败，可以通过消息队列异步重试，或者用 Canal 订阅 binlog 自动删除。需要注意的是，这个方案只能保证最终一致性，不能保证强一致性。"

---

## 七、集群

### 8. Redis 的集群方案有哪些？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：Redis 有三种集群方案——主从复制、哨兵模式、Cluster 集群。生产环境高可用一般用哨兵或 Cluster。

**通俗理解**：

- **主从复制** = 一个老板（主节点）带几个秘书（从节点），老板负责写，秘书负责读，秘书抄老板的内容。但老板挂了没人顶上
- **哨兵模式** = 在主从的基础上加了几个"保安"（哨兵），时刻盯着老板。老板挂了，保安自动选一个秘书升职当老板 → ⚡**自动故障转移**
- **Cluster 集群** = 开了多家分店，每家店负责一部分商品。既能分担压力（分片），每家店还有备份员工（从节点）→ ⚡**分片 + 高可用**

**回到技术**："抄老板的内容"就是主从数据同步。"保安选秘书升职"就是哨兵通过投票选举新的主节点。"多家分店"就是 Cluster 把数据分成 ⚡**16384 个哈希槽**，分布到不同节点上。

| 方案 | 特点 | 适用场景 |
|------|------|---------|
| **主从复制** | 读写分离，但主节点故障需⚡**手动切换** | 读多写少，对可用性要求不高 |
| **哨兵模式** | 自动故障转移，但⚡**不支持数据分片** | 数据量不大，需要高可用 |
| **Cluster** | ⚡**分片 + 高可用**，支持水平扩展 | 数据量大、并发高的生产环境 |

> **Cluster 的哈希槽**：Redis Cluster 把所有 key 映射到 ⚡**16384** 个槽（slot），每个节点负责一部分槽。`slot = CRC16(key) % 16384`。扩缩容时只需要迁移部分槽，不影响整体服务。

**🎤 面试这样答**：
> "Redis 集群有三种方案：主从复制实现读写分离但故障需手动切换；哨兵模式在主从基础上加了自动故障转移，但不支持数据分片；Cluster 模式既支持分片又支持高可用，把数据分到 16384 个哈希槽分布在不同节点上。生产环境数据量大一般用 Cluster。"

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | Redis 为什么这么快？ |
| ⭐⭐⭐⭐⭐ | 缓存穿透、击穿、雪崩？ |
| ⭐⭐⭐⭐⭐ | Redis 持久化（RDB vs AOF）？ |
| ⭐⭐⭐⭐⭐ | Redis 分布式锁？ |
| ⭐⭐⭐⭐⭐ | 缓存和数据库一致性？ |
| ⭐⭐⭐⭐ | Redis 数据类型？ |
| ⭐⭐⭐⭐ | 过期删除和内存淘汰策略？ |
| ⭐⭐⭐⭐ | Redis 集群方案？ |
