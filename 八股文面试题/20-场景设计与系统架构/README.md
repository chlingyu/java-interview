# 20 - 场景设计与系统架构

> 覆盖系统设计核心知识：秒杀系统、限流方案、接口幂等性、读写分离与分库分表等高频场景面试考点。秒杀系统和限流几乎每场必问。

---

## 一、秒杀

### 1. 秒杀系统怎么设计？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：秒杀的核心思路是"层层过滤、最终落库"——尽量把请求挡在上游，只让极少数请求到达数据库。

**通俗理解**：

秒杀就像演唱会抢票。10 万人同时抢 100 张票，不可能让 10 万人都冲到售票窗口。正确的做法是：

1. **门口保安拦一波**（前端限流）= 按钮点一次就灰掉，防止重复提交
2. **检票口再拦一波**（网关限流）= 同一个用户 1 秒内只能请求一次
3. **候场区排队**（MQ 削峰）= 请求先进队列，后端按能力消费
4. **最终只放 100 人进场**（Redis 预扣库存）= 库存扣完直接拒绝，不打数据库

**回到技术**："保安拦人"就是前端做按钮防抖和倒计时。"检票口"就是网关层的限流和风控。"排队"就是用 MQ 缓冲请求。"放 100 人进场"就是用 Redis 原子操作预扣库存，库存为 0 后所有请求直接返回"已售罄"。

**秒杀架构分层**：

```
前端                    网关                     服务层                    数据层
按钮防抖 ──→ 限流/风控 ──→ Redis 预扣库存 ──→ MQ 异步下单 ──→ MySQL 扣减库存
倒计时       IP/用户限频    库存≤0直接拒绝      削峰填谷        最终落库
静态化       验证码                                            乐观锁防超卖
```

**关键技术点**：

| 问题 | 方案 |
|------|------|
| **防超卖** | Redis 用 Lua 脚本原子扣减库存；MySQL 用⚡**乐观锁** `WHERE stock > 0` |
| **防重复下单** | 用户维度加分布式锁，或订单表唯一索引（用户ID + 商品ID） |
| **高并发读** | 商品详情页⚡**静态化** + CDN 缓存，库存走 Redis |
| **异步下单** | Redis 扣减成功后发 MQ 消息，消费者异步创建订单 |

**🎤 面试这样答**：
> "秒杀系统的核心思路是层层过滤。前端做按钮防抖和页面静态化，网关层做限流和风控，服务层用 Redis Lua 脚本原子扣减库存，库存为 0 直接拒绝。扣减成功的请求通过 MQ 异步下单，消费者创建订单并扣减 MySQL 库存，用乐观锁 WHERE stock > 0 防超卖。整个链路的目标是把 99% 的请求挡在数据库之前。"

---

## 二、限流

### 2. 常见的限流算法？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：常见的限流算法有四种——固定窗口、滑动窗口、漏桶、令牌桶。生产环境最常用的是令牌桶算法。

**通俗理解**：

限流就像高速公路收费站控制车流量：

- **固定窗口** = 每小时只放 100 辆车。但如果 100 辆车都集中在这小时的最后 1 分钟和下小时的第 1 分钟通过，2 分钟内就过了 200 辆 → ⚡**临界突刺问题**
- **滑动窗口** = 把 1 小时拆成 6 个 10 分钟的小窗口，每个小窗口单独计数，窗口滑动统计 → 缓解突刺
- **漏桶** = 不管来多少车，收费站按固定速率放行（每分钟 10 辆），多的车排队等 → 流量整形，⚡**无法应对突发流量**
- **令牌桶** = 收费站以固定速率发放通行证（令牌），车来了有令牌就放行，没令牌就等。桶里可以攒一些令牌，所以能应对短暂的突发流量 → ⚡**最常用**

**回到技术**："发放通行证"就是令牌桶以固定速率往桶里放令牌。"攒令牌"就是桶有容量上限，空闲时令牌会积累，突发流量来时可以一次性消耗多个令牌。

| 算法 | 原理 | 优缺点 |
|------|------|--------|
| 固定窗口 | 时间窗口内计数，超过阈值拒绝 | 简单，但有临界突刺问题 |
| 滑动窗口 | 细分时间窗口，滑动统计 | 缓解突刺，Sentinel 默认用这个 |
| 漏桶 | 固定速率处理请求 | 流量平滑，但无法应对突发 |
| ⚡**令牌桶** | 固定速率放令牌，有令牌才放行 | 允许突发流量，Guava RateLimiter 用的就是这个 |

**🎤 面试这样答**：
> "常见限流算法有四种。固定窗口按时间段计数，简单但有临界突刺问题；滑动窗口把时间段细分，缓解突刺；漏桶按固定速率处理请求，流量平滑但无法应对突发；令牌桶以固定速率放令牌，允许一定程度的突发流量，是最常用的方案。Java 中 Guava 的 RateLimiter 就是令牌桶实现，分布式场景可以用 Redis + Lua 脚本实现滑动窗口限流。"

---

## 三、幂等性

### 3. 如何保证接口幂等性？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：幂等性是指同一个请求执行一次和执行多次的效果一样。常见方案有 Token 机制、唯一索引、乐观锁、Redis SET NX。

**通俗理解**：

电梯按钮就是幂等的——你按一次和按十次，电梯都只来一趟。但如果每按一次电梯就多来一趟，那就不幂等了。接口幂等性就是要保证用户因为网络抖动、重试等原因重复提交请求时，服务端只处理一次。

**回到技术**："按一次和按十次效果一样"就是幂等性的定义——同一个请求执行多次，结果和执行一次相同。GET 和 DELETE 天然幂等，POST 和部分 UPDATE 不幂等。核心思路是在服务端通过唯一标识判断请求是否已经处理过，处理过就直接返回，不重复执行。

| 方案 | 原理 | 适用场景 |
|------|------|---------|
| **Token 机制** | 提交前先获取 Token 存 Redis，提交时校验并删除 Token，第二次提交 Token 已不存在 | ⚡**表单重复提交** |
| **唯一索引** | 数据库表加 UNIQUE KEY，重复插入直接报错 | 插入场景 |
| **乐观锁** | `UPDATE SET version=version+1 WHERE version=?`，版本号不对就更新失败 | 更新场景 |
| **Redis SET NX** | 用请求唯一标识做 key，SET NX 成功才处理 | 通用方案 |

**🎤 面试这样答**：
> "保证接口幂等性常见四种方案：Token 机制适合防表单重复提交，提交前先获取 Token，提交时校验并删除；插入场景用数据库唯一索引兜底；更新场景用乐观锁加版本号控制；通用方案是用 Redis SET NX，请求的唯一标识作为 key，设置成功才处理业务。"

---

## 四、数据库架构

### 4. 读写分离和分库分表？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：读写分离是写操作走主库、读操作走从库，解决读多写少的性能问题；分库分表是把数据分散到多个库或表中，解决单库单表数据量过大的问题。

**通俗理解**：

- **读写分离** = 一家餐厅，前台负责接单（写），后厨有多个窗口同时出餐（读）。接单只需要一个窗口，但出餐窗口可以有很多个 → 一主多从
- **分库分表** = 一家超市货太多放不下了，要么多开几家分店（分库），要么把一个大货架拆成多个小货架（分表）

**回到技术**："一主多从"就是 MySQL 主从复制，主库负责写，从库通过 binlog 同步数据后负责读。"多开分店"就是把不同业务的数据放到不同数据库实例（垂直分库），"拆货架"就是把一张大表按规则拆成多张小表（水平分表）。

**读写分离**：

| 要点 | 说明 |
|------|------|
| 原理 | 主库写，从库读，通过 binlog 异步同步 |
| 主从延迟 | 从库数据可能比主库慢几十毫秒到几秒 |
| 解决延迟 | 关键业务强制读主库；写后立即读走主库 |
| 中间件 | ShardingSphere、MyCat、Spring 的 `AbstractRoutingDataSource` |

**分库分表**：

| 方式 | 做法 | 解决的问题 |
|------|------|-----------|
| **垂直分库** | 按业务拆库（用户库、订单库、商品库） | 业务解耦，减少单库压力 |
| **垂直分表** | 把大字段拆到扩展表（如商品详情单独一张表） | 减少单行数据量，提升查询效率 |
| **水平分表** | 按规则把数据分散到多张表（如按用户 ID 取模） | ⚡**单表数据量过大**（建议单表不超过 500 万行） |
| **水平分库** | 按规则把数据分散到多个库实例 | 单库连接数和存储瓶颈 |

> **分库分表带来的问题**：跨库 JOIN 困难、分布式事务、全局排序和分页复杂、数据迁移成本高。所以⚡**能不分就不分**，先考虑读写分离、缓存、索引优化，实在扛不住再分。中间件推荐 ShardingSphere。

**🎤 面试这样答**：
> "读写分离是主库负责写、从库负责读，通过 binlog 同步，适合读多写少的场景，要注意主从延迟问题。分库分表分为垂直和水平两种：垂直是按业务拆分，水平是按规则把数据分散到多张表或多个库。水平分表一般在单表超过 500 万行时考虑，分片键的选择很关键，通常用业务 ID 取模。但分库分表会引入跨库查询、分布式事务等问题，所以应该作为最后手段。"

---

## 五、系统设计

### 5. 如何设计一个短链系统？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：短链系统就是把长 URL 转成短 URL（如 `https://t.cn/abc123`），用户访问短链时 ⚡**301/302 重定向**到原始长链接。

核心设计思路：用自增 ID 或分布式 ID 生成唯一数字，再把数字转成⚡**62 进制**（0-9 + a-z + A-Z）得到短码。

```
生成短链流程：
① 接收长 URL
② 生成唯一 ID（雪花算法 / 自增 ID）
③ 将 ID 转为 62 进制字符串，如 1234567 → "w7E"
④ 拼接域名：https://t.cn/w7E
⑤ 存储映射关系：短码 → 长 URL（MySQL + Redis 缓存）
```

| 设计要点 | 方案 |
|---------|------|
| **短码生成** | 自增 ID + 62 进制编码（⚡**6 位 62 进制可表示 568 亿个**） |
| **防重复** | 同一个长 URL 先查缓存/数据库，已存在直接返回 |
| **高性能读** | 短码→长 URL 的映射缓存到 Redis，命中率极高 |
| **301 vs 302** | 301 永久重定向（浏览器缓存，减少服务端压力）；302 临时重定向（方便统计点击量） |

---

## 六、延迟任务

### 6. 订单超时未支付自动取消怎么实现？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：核心是"延迟任务"——订单创建后等待一段时间，如果还没支付就自动取消。主流方案有 RocketMQ 延迟消息、Redis 过期监听、时间轮、定时扫表。

**通俗理解**：

你在外卖 App 下了单但没付款，App 会提示"请在 15 分钟内完成支付，否则自动取消"。这背后就是一个延迟任务：下单时设一个 15 分钟的"闹钟"，闹钟响了检查一下有没有付款，没付就取消订单、释放库存。

**回到技术**："设闹钟"就是创建一个延迟任务，"闹钟响了"就是延迟时间到了触发回调。关键问题是这个"闹钟"怎么实现才能既准时又扛得住高并发。

**常见方案对比**：

| 方案 | 原理 | 优点 | 缺点 |
|------|------|------|------|
| ⚡**RocketMQ 延迟消息** | 下单时发一条延迟消息，到期后消费者收到并检查支付状态 | 可靠性高，天然支持分布式 | 延迟级别有限（RocketMQ 固定 18 个级别） |
| **Redis 过期 + 键空间通知** | 设置一个 key 过期时间为 30 分钟，过期时触发回调 | 实现简单 | ⚠️ 不可靠，Redis 的过期通知是"尽力而为"，可能丢消息 |
| **Redis ZSet** | 用订单超时时间作为 score，定时轮询取出到期的订单 | 精度高，实现灵活 | 需要自己写轮询逻辑 |
| ⚡**时间轮（HashedWheelTimer）** | 类似钟表，指针转一圈触发对应格子里的任务 | 性能极高，Netty/Kafka 内部都在用 | 单机方案，重启任务丢失 |
| **定时扫表** | 定时任务每隔 N 秒扫描订单表，找出超时未支付的订单 | 最简单，不依赖中间件 | 数据量大时扫表慢，有延迟 |

**生产推荐方案**：

```
下单 → 发送 RocketMQ 延迟消息（延迟 30 分钟）
       ↓
30 分钟后消费者收到消息
       ↓
查询订单状态：已支付？→ 忽略
              未支付？→ 取消订单 + 释放库存
```

> **兜底机制**：延迟消息可能极端情况下丢失，所以还需要一个⚡**定时扫表兜底**——每隔 5 分钟扫一次订单表，把超时未支付且未被处理的订单补偿取消。

**🎤 面试这样答**：
> "订单超时取消的核心是延迟任务。生产中推荐用 RocketMQ 延迟消息，下单时发一条延迟 30 分钟的消息，到期后消费者检查订单状态，未支付就取消订单释放库存。同时加一个定时扫表作为兜底，防止消息丢失。其他方案还有 Redis ZSet 轮询、时间轮等，Redis 键空间通知不推荐，因为过期通知不可靠可能丢消息。"

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | 秒杀系统怎么设计？ |
| ⭐⭐⭐⭐⭐ | 常见的限流算法？ |
| ⭐⭐⭐⭐ | 订单超时未支付自动取消？ |
| ⭐⭐⭐⭐ | 如何保证接口幂等性？ |
| ⭐⭐⭐⭐ | 读写分离和分库分表？ |
| ⭐⭐⭐ | 如何设计一个短链系统？ |