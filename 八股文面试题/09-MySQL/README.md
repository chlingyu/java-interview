# 09 - MySQL

> 覆盖 MySQL 核心知识：索引原理（B+树）、事务隔离级别、MVCC、锁机制、慢 SQL 优化等高频面试考点。索引和事务是面试重灾区。

---

## 一、索引

### 1. MySQL 索引的底层数据结构？为什么用 B+ 树？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：InnoDB 的索引底层用 B+ 树，因为它矮胖（层数少、IO 少）、叶子节点有序链表（范围查询快）。

**通俗理解**：

想象你在一本 1000 页的字典里查一个字：
- **没有索引** = 从第 1 页翻到第 1000 页，逐页找 → 全表扫描
- **二叉树** = 每次排除一半，但树太高了，要翻很多次 → 磁盘 IO 多
- **B+ 树** = 像字典的目录，先看"A~F 在第几章"，再看"AB~AF 在第几节"，两三次就定位到了 → ⚡**树高通常只有 3~4 层**

**回到技术**："翻一次目录"就是一次磁盘 IO。B+ 树每个节点可以存上千个 key（因为非叶子节点不存数据，只存索引），所以树非常"矮胖"。3 层的 B+ 树就能存储⚡**约 2000 万行**数据，查任何一行最多 3 次 IO。

**原理详解**：

**为什么不用其他数据结构？**

| 数据结构 | 问题 |
|---------|------|
| 哈希表 | 只能精确查找，⚡**不支持范围查询**（`WHERE age > 20`） |
| 二叉搜索树 | 可能退化成链表，树太高 |
| AVL/红黑树 | 每个节点只存一个 key，树高 = log₂(n)，数据量大时太高 |
| B 树 | 非叶子节点也存数据，每个节点能放的 key 少，树更高 |
| **B+ 树** | ⚡非叶子节点只存 key 不存数据，更矮；叶子节点用链表串联，范围查询快 |

```
B+ 树结构示意

         ┌──────────────┐
         │  [10, 20, 30] │          ← 非叶子节点：只存 key，不存数据
         └──┬─────┬────┬─┘
            │     │    │
     ┌──────▼┐ ┌──▼──┐ ┌▼──────┐
     │ 1~9   │ │10~19│ │20~30  │   ← 叶子节点：存完整数据
     └───────┤ └─────┤ └───────┘
             →       →              ← 叶子节点之间用双向链表连接（范围查询直接遍历）
```

**🎤 面试这样答**：
> "InnoDB 索引用 B+ 树实现。选 B+ 树有三个原因：一是非叶子节点只存索引不存数据，一个节点能放更多 key，树更矮，3 层就能存两千万行数据；二是叶子节点用双向链表连接，范围查询只需找到起点然后顺着链表遍历，非常高效；三是所有数据都在叶子节点，查询路径长度一致，性能稳定。"

---

### 2. 聚簇索引和非聚簇索引的区别？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：聚簇索引的叶子节点存的是完整数据行，非聚簇索引（二级索引）的叶子节点存的是主键值。

**通俗理解**：

- **聚簇索引** = 新华字典的正文，按拼音排序，翻到那一页内容就在那里
- **非聚簇索引** = 字典后面的偏旁部首索引，查到的是"这个字在第几页"，还得翻到那一页去看内容（⚡**回表**）

**回到技术**："正文"就是 InnoDB 的数据文件本身就是按主键组织的 B+ 树，叶子节点存完整行数据。"偏旁部首索引"就是你建的普通索引，叶子节点只存主键 ID，要拿完整数据还得拿着主键 ID 去聚簇索引再查一次。

| 对比项 | 聚簇索引 | 非聚簇索引（二级索引） |
|--------|---------|---------------------|
| 叶子节点存什么 | ⚡**完整数据行** | ⚡**主键值** |
| 每张表有几个 | 只有 ⚡**1 个**（就是主键索引） | 可以有多个 |
| 查询效率 | 直接拿到数据 | 可能需要**回表**（拿主键再查一次聚簇索引） |

> **什么是回表？** 通过二级索引查到主键值后，再回到聚簇索引查完整数据，这个过程叫回表。回表意味着两次 B+ 树查找，性能不如直接走聚簇索引。

**🎤 面试这样答**：
> "InnoDB 中聚簇索引就是主键索引，叶子节点存完整数据行，每张表只有一个。非聚簇索引也叫二级索引，叶子节点存的是主键值。通过二级索引查询时，如果需要的字段不在索引中，就要拿着主键回到聚簇索引再查一次，这就是回表。所以设计索引时要尽量利用覆盖索引避免回表。"

---

### 3. 什么是覆盖索引？什么是索引下推？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：覆盖索引是指查询的字段全部在索引中，不需要回表；索引下推（ICP）是在索引遍历时提前过滤不符合条件的记录，减少回表次数。

**通俗理解**：

还是字典的例子：
- **覆盖索引** = 你只想知道"这个字的拼音"，偏旁部首索引上就写着拼音，不用翻到正文去看 → ⚡**不需要回表**
- **索引下推** = 你要找"偏旁是木、笔画数是 8"的字。以前是先按偏旁找出所有"木"字旁的字，再一个个翻到正文看笔画数。现在优化了——在偏旁索引上就能看到笔画数，不符合的直接跳过，⚡**少翻很多页**

**回到技术**："不用翻到正文"就是查询所需的所有列都包含在索引中，直接从索引就能拿到结果。"在索引上就能看到笔画数"就是 MySQL 5.6 引入的 **ICP（Index Condition Pushdown）**，把原本在 Server 层做的条件过滤"下推"到存储引擎层，在索引遍历阶段就过滤掉不满足条件的记录。

**覆盖索引示例**：

```sql
-- 假设有联合索引 idx_name_age(name, age)

-- ✅ 覆盖索引：查询的字段 name、age 都在索引中，不需要回表
SELECT name, age FROM user WHERE name = '张三';

-- ❌ 需要回表：email 不在索引中，必须拿主键回聚簇索引查
SELECT name, age, email FROM user WHERE name = '张三';
```

> **怎么判断是否用了覆盖索引？** 看 `EXPLAIN` 的 Extra 列，出现 ⚡**Using index** 就说明用了覆盖索引。

**索引下推示例**：

```sql
-- 联合索引 idx_name_age(name, age)
SELECT * FROM user WHERE name LIKE '张%' AND age = 25;
```

```
没有 ICP（MySQL 5.6 之前）：
  ① 存储引擎用索引找到所有 name LIKE '张%' 的记录（可能几百条）
  ② 每条都回表拿完整数据
  ③ Server 层再用 age = 25 过滤 → 回表了很多无用的行

有 ICP（MySQL 5.6+）：
  ① 存储引擎用索引找到 name LIKE '张%' 的记录
  ② 在索引中直接判断 age = 25，不满足的直接跳过
  ③ 只有满足条件的才回表 → ⚡ 大幅减少回表次数
```

> EXPLAIN 的 Extra 列出现 **Using index condition** 就说明用了索引下推。

**🎤 面试这样答**：
> "覆盖索引是指查询需要的所有字段都在索引中，不需要回表查聚簇索引，EXPLAIN 中显示 Using index。索引下推是 MySQL 5.6 引入的优化，在联合索引中，把原本在 Server 层做的条件判断下推到存储引擎层，在索引遍历阶段就过滤掉不满足条件的记录，减少回表次数，EXPLAIN 中显示 Using index condition。"

---

### 4. 哪些情况会导致索引失效？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：对索引列做函数运算、隐式类型转换、左模糊查询、违反最左前缀原则等，都会导致索引失效走全表扫描。

**通俗理解**：

索引就像字典的目录，但你得"按规矩查"才能用上目录。如果你不按拼音查，非要从中间某个字母开始找，或者把字改了个形态再查，目录就帮不上忙了，只能一页页翻。

**回到技术**："不按拼音查"就是违反最左前缀原则，"改了形态"就是对索引列做了函数运算或类型转换，MySQL 优化器发现用索引还不如全表扫描快时，就会放弃索引。

**原理详解**：

假设有联合索引 `idx_a_b_c(a, b, c)`：

| 失效场景 | 示例 | 原因 |
|---------|------|------|
| **对索引列使用函数** | `WHERE YEAR(create_time) = 2024` | 函数改变了索引值，B+ 树无法定位 |
| **隐式类型转换** | `WHERE varchar_col = 123`（字符串列用数字查） | MySQL 会对列做隐式转换，等于加了函数 |
| **左模糊查询** | `WHERE name LIKE '%张'` | B+ 树按前缀排序，左边不确定就没法用索引 |
| **违反最左前缀** | `WHERE b = 1 AND c = 2`（跳过了 a） | 联合索引必须从最左列开始匹配 |
| **OR 连接非索引列** | `WHERE a = 1 OR d = 2`（d 没有索引） | OR 中有一个条件没索引，整体就走全表扫描 |
| **NOT IN / !=** | `WHERE a != 1` | 否定条件通常无法利用索引的有序性 |

**最左前缀原则详解**：

```
联合索引 idx_a_b_c(a, b, c) 相当于创建了三个索引：
  ✅ (a)
  ✅ (a, b)
  ✅ (a, b, c)

能用上索引的查询：
  ✅ WHERE a = 1
  ✅ WHERE a = 1 AND b = 2
  ✅ WHERE a = 1 AND b = 2 AND c = 3
  ✅ WHERE a = 1 AND c = 3        → a 能用索引，c 用不上（b 断了）

用不上索引的查询：
  ❌ WHERE b = 2                  → 跳过了 a
  ❌ WHERE b = 2 AND c = 3        → 跳过了 a
  ❌ WHERE c = 3                  → 跳过了 a 和 b
```

> **注意**：`WHERE a = 1 AND b > 2 AND c = 3` 中，a 和 b 能用索引，但 c ⚡**用不上**——因为 b 是范围查询，范围查询之后的列无法使用索引。

**🎤 面试这样答**：
> "索引失效的常见场景有：一是对索引列使用函数或运算，比如 YEAR(create_time)；二是隐式类型转换，字符串列用数字查会触发转换；三是左模糊查询 LIKE '%xxx'；四是违反联合索引的最左前缀原则；五是 OR 连接中有非索引列。排查索引失效最直接的方法是用 EXPLAIN 看执行计划，关注 type 和 key 字段。"

---

## 二、事务

### 5. 事务的四大特性（ACID）？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐

**一句话回答**：事务有四大特性——原子性（A）、一致性（C）、隔离性（I）、持久性（D），保证数据库操作要么全成功要么全失败，数据始终正确。

**通俗理解**：

把事务想象成银行转账——你给朋友转 100 块：
- **原子性（Atomicity）**：你的账户扣 100 和朋友账户加 100，要么都成功，要么都不做。不能出现你扣了钱但朋友没收到的情况
- **一致性（Consistency）**：转账前后，你俩的钱加起来总数不变。不能凭空多出钱或少了钱
- **隔离性（Isolation）**：你在转账的时候，别人查你的余额不会看到"扣了但还没到账"的中间状态
- **持久性（Durability）**：转账成功后，即使银行系统崩了重启，这笔转账记录也不会丢

**回到技术**：MySQL 通过不同机制保证 ACID：

| 特性 | 实现机制 |
|------|---------|
| 原子性 | ⚡**undo log**（回滚日志）：记录操作的逆操作，失败时回滚 |
| 一致性 | 由其他三个特性共同保证（一致性是目的，AID 是手段） |
| 隔离性 | ⚡**MVCC + 锁机制** |
| 持久性 | ⚡**redo log**（重做日志）：事务提交前先写日志，崩溃后可重放恢复 |

> **面试追问**：一致性和其他三个的关系？一致性是最终目标，原子性、隔离性、持久性是实现一致性的手段。如果原子性被破坏（操作只做了一半），或隔离性被破坏（读到脏数据），一致性就无法保证。

---

### 6. MySQL 的事务隔离级别？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：MySQL 有四种隔离级别，从低到高：读未提交、读已提交、可重复读（⚡**InnoDB 默认**）、串行化。隔离级别越高，数据越安全，但并发性能越差。

**通俗理解**：

把数据库想象成一间办公室，事务就是在办公室里干活的人：

- **读未提交（Read Uncommitted）** = 你在写报告，旁边的人直接凑过来看你还没写完的草稿。你后来把草稿删了重写，他看到的就是错的 → ⚡**脏读**
- **读已提交（Read Committed）** = 别人只能看你写完提交后的报告。但你提交了两版，他第一次看是 V1，第二次看变成 V2 了 → ⚡**不可重复读**
- **可重复读（Repeatable Read）** = 别人在你开始干活时拍了一张快照，之后不管你怎么改，他看到的都是快照里的内容。但如果你新增了一份文件，他可能会"突然发现多了一份" → ⚡**幻读**
- **串行化（Serializable）** = 一次只能一个人进办公室干活，其他人在门口排队。绝对安全，但⚡**效率最低**

**回到技术**："看草稿"就是读到了未提交的数据（脏读）。"快照"就是 MVCC 的 ReadView 机制。"突然多了一份文件"就是幻读——同一个查询条件，前后两次查到的行数不一样。

**原理详解**：

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 性能 |
|---------|------|-----------|------|------|
| 读未提交 | ⚡有 | 有 | 有 | 最高 |
| 读已提交（Oracle 默认） | ✅ 解决 | ⚡有 | 有 | 高 |
| **可重复读（MySQL 默认）** | ✅ 解决 | ✅ 解决 | ⚡部分解决 | 中 |
| 串行化 | ✅ 解决 | ✅ 解决 | ✅ 解决 | 最低 |

**三种读异常解释**：

| 问题 | 含义 | 例子 |
|------|------|------|
| **脏读** | 读到别人⚡**未提交**的数据 | 事务 A 改了数据还没提交，事务 B 读到了，A 回滚了，B 读到的就是脏数据 |
| **不可重复读** | 同一行数据，前后两次读的⚡**值不同** | 事务 B 第一次读 age=20，事务 A 把 age 改成 25 并提交，事务 B 再读变成 25 了 |
| **幻读** | 同一个查询条件，前后两次读的⚡**行数不同** | 事务 B 查 age>20 得到 3 行，事务 A 插入一行 age=25 并提交，事务 B 再查变成 4 行了 |

> **MySQL 的可重复读能解决幻读吗？** InnoDB 的可重复读通过 ⚡**MVCC** 解决了快照读（普通 SELECT）的幻读问题，但当前读（`SELECT ... FOR UPDATE`）的幻读需要通过 ⚡**临键锁（Next-Key Lock）** 来解决。所以说是"部分解决"。

**🎤 面试这样答**：
> "MySQL 有四种隔离级别：读未提交、读已提交、可重复读、串行化。InnoDB 默认是可重复读。读未提交会有脏读问题；读已提交解决了脏读但有不可重复读；可重复读通过 MVCC 解决了不可重复读，快照读下也不会幻读，但当前读的幻读需要靠临键锁解决；串行化最安全但性能最差。实际开发中一般用默认的可重复读就够了。"

---

### 7. MVCC 的原理？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：MVCC（Multi-Version Concurrency Control，多版本并发控制）通过 undo log 版本链 + ReadView 实现，让读操作不加锁也能看到一致的数据快照。

**通俗理解**：

把数据库想象成一个 Google Docs 文档，支持查看历史版本：
- 每次有人修改文档，系统不会覆盖原内容，而是保存一个新版本，旧版本还在 → 这就是 **undo log 版本链**
- 你打开文档时，系统给你拍了一张"快照"，告诉你"你能看到哪些版本" → 这就是 **ReadView**
- 之后不管别人怎么改，你看到的始终是你打开时的那个版本 → 这就是⚡**快照读**

**回到技术**："保存新版本"就是每次 UPDATE 都会把旧数据写入 undo log，通过 **roll_pointer（回滚指针）** 串成一条版本链。"快照"就是 ReadView，它记录了当前活跃的事务 ID 列表，用来判断版本链上哪个版本对当前事务可见。

**原理详解**：

**① 隐藏字段**：InnoDB 每行数据都有两个隐藏列：

| 隐藏字段 | 含义 |
|---------|------|
| **trx_id** | 最近一次修改该行的⚡**事务 ID** |
| **roll_pointer** | 指向 undo log 中该行的⚡**上一个版本** |

**② 版本链**：

```
当前数据行：name = "王五", trx_id = 300
        │ roll_pointer
        ▼
undo log：name = "李四", trx_id = 200
        │ roll_pointer
        ▼
undo log：name = "张三", trx_id = 100
```

**③ ReadView**：事务执行快照读时生成，包含四个关键字段：

| 字段 | 含义 |
|------|------|
| **m_ids** | 生成 ReadView 时，当前所有⚡**活跃（未提交）事务**的 ID 列表 |
| **min_trx_id** | m_ids 中的最小值 |
| **max_trx_id** | 系统下一个要分配的事务 ID（不是 m_ids 的最大值） |
| **creator_trx_id** | 创建该 ReadView 的事务 ID |

**④ 可见性判断规则**：拿版本链上每个版本的 trx_id 按以下规则判断：

```
trx_id == creator_trx_id？ → ✅ 自己改的，可见
trx_id < min_trx_id？     → ✅ 在 ReadView 创建前就提交了，可见
trx_id >= max_trx_id？    → ❌ 在 ReadView 创建后才开始的，不可见
trx_id 在 m_ids 中？      → ❌ 还没提交，不可见
trx_id 不在 m_ids 中？    → ✅ 已经提交了，可见
```

> 沿着版本链从新到旧逐个判断，找到第一个可见的版本就返回。

**⑤ RC 和 RR 的区别**：

| 隔离级别 | ReadView 生成时机 |
|---------|-----------------|
| **读已提交（RC）** | ⚡**每次** SELECT 都生成新的 ReadView |
| **可重复读（RR）** | ⚡**第一次** SELECT 时生成，之后复用同一个 ReadView |

> 这就是为什么 RR 级别下同一个事务内多次读结果一致——因为用的是同一个 ReadView，看到的版本链快照不会变。

**🎤 面试这样答**：
> "MVCC 的核心是 undo log 版本链加 ReadView。每行数据有隐藏的 trx_id 和 roll_pointer，每次修改都会在 undo log 中保留旧版本，通过 roll_pointer 串成版本链。事务做快照读时会生成 ReadView，记录当前活跃事务列表，然后沿着版本链判断每个版本是否可见。RC 级别每次 SELECT 都生成新的 ReadView，所以能读到最新提交的数据；RR 级别只在第一次 SELECT 时生成 ReadView 并复用，所以同一事务内读到的数据一致。"

---

## 三、锁

### 8. MySQL 有哪些锁？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐⭐

**一句话回答**：MySQL 的锁可以从粒度、模式、算法三个维度分类。InnoDB 支持行锁和表锁，行锁又分为记录锁、间隙锁、临键锁。

**通俗理解**：

把数据库想象成一栋公寓楼：
- **表锁** = 锁整栋楼，谁都不能进 → 粒度最大，冲突最多
- **行锁** = 只锁某一间房，其他房间随便进出 → 粒度最小，并发最高
- **间隙锁** = 锁两间房之间的空位，不让新住户搬进来 → 防止幻读
- **临键锁** = 锁一间房 + 它前面的空位 → 记录锁 + 间隙锁的组合

**回到技术**："锁整栋楼"就是对整张表加锁，MyISAM 只支持表锁。"锁某一间房"就是 InnoDB 的行级锁，锁的是索引记录。"锁空位"就是间隙锁（Gap Lock），锁的是索引记录之间的间隙，防止其他事务在间隙中插入新行。

**原理详解**：

**按粒度分**：

| 锁类型 | 锁什么 | 特点 |
|--------|-------|------|
| **表锁** | 整张表 | 开销小，加锁快，⚡**并发度最低** |
| **行锁** | 索引记录 | 开销大，加锁慢，⚡**并发度最高** |

> InnoDB 的行锁是⚡**加在索引上的**。如果查询没有走索引，行锁会退化为表锁。

**按模式分**：

| 锁模式 | 说明 |
|--------|------|
| **共享锁（S 锁）** | 读锁，多个事务可以同时持有，`SELECT ... LOCK IN SHARE MODE` |
| **排他锁（X 锁）** | 写锁，只有一个事务能持有，`SELECT ... FOR UPDATE` / INSERT / UPDATE / DELETE |

**按算法分（InnoDB 行锁的三种形态）**：

| 锁算法 | 锁什么 | 作用 |
|--------|-------|------|
| **记录锁（Record Lock）** | ⚡锁住某一行记录 | 防止其他事务修改或删除该行 |
| **间隙锁（Gap Lock）** | ⚡锁住两条记录之间的间隙 | 防止其他事务在间隙中插入新行（防幻读） |
| **临键锁（Next-Key Lock）** | ⚡记录锁 + 间隙锁，左开右闭区间 | InnoDB 在 RR 级别下的⚡**默认行锁算法** |

```
假设表中有 id = 1, 5, 10 三条记录

记录锁：锁住 id=5 这一行
间隙锁：锁住 (1, 5) 或 (5, 10) 这个间隙，不让插入新行
临键锁：锁住 (1, 5] 这个区间（间隙 + 记录本身）
```

**🎤 面试这样答**：
> "MySQL 的锁从粒度上分为表锁和行锁，InnoDB 支持行锁，行锁是加在索引上的，如果没走索引会退化为表锁。从模式上分为共享锁和排他锁。InnoDB 的行锁有三种算法：记录锁锁单行，间隙锁锁两条记录之间的间隙防止插入，临键锁是两者的组合，是 RR 级别下的默认行锁算法，用来解决幻读问题。"

---

### 9. 什么是死锁？怎么解决？

> ⭐⭐⭐ 常问 | 难度：⭐⭐⭐

**回答**：死锁就是两个事务互相等待对方释放锁，谁也不让谁，永远卡住。你可以理解为两个人过独木桥，都走到中间不肯退，谁也过不去。

```
事务 A：持有行 1 的锁 → 等待行 2 的锁
事务 B：持有行 2 的锁 → 等待行 1 的锁
→ 互相等待，死锁！
```

**InnoDB 的死锁处理**：InnoDB 有⚡**死锁检测机制**（`wait-for graph` 等待图算法），检测到死锁后会自动回滚代价较小的事务（持有锁最少的那个），让另一个事务继续执行。

**如何避免死锁**：

| 方法 | 说明 |
|------|------|
| 固定加锁顺序 | 所有事务按⚡**相同的顺序**访问表和行 |
| 缩短事务 | 事务越短，持锁时间越短，冲突概率越低 |
| 合理使用索引 | 避免行锁退化为表锁，减少锁范围 |
| 降低隔离级别 | RC 级别没有间隙锁，死锁概率更低 |

---

## 四、性能优化

### 10. 慢 SQL 怎么排查和优化？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：先通过慢查询日志定位慢 SQL，再用 EXPLAIN 分析执行计划，最后针对性优化——加索引、改写 SQL、优化表结构。

**通俗理解**：

SQL 变慢就像堵车。排查思路和治堵一样：
1. 先装个行车记录仪，看看哪条路堵了 → ⚡**开启慢查询日志**
2. 拿出地图分析这条路为什么堵 → ⚡**用 EXPLAIN 看执行计划**
3. 对症下药：修路（加索引）、改路线（改写 SQL）、限流（分页优化）

**回到技术**："行车记录仪"就是 MySQL 的慢查询日志（slow_query_log），会记录执行时间超过阈值的 SQL。"地图"就是 EXPLAIN 命令，能看到 SQL 走了哪个索引、扫描了多少行、有没有用临时表等。

**原理详解**：

**第一步：定位慢 SQL**

```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = ON;
SET GLOBAL long_query_time = 1;  -- 超过 1 秒的 SQL 记录下来
```

**第二步：EXPLAIN 分析**（详见下一题）

**第三步：常见优化手段**

| 优化方向 | 具体做法 |
|---------|---------|
| **加索引** | 给 WHERE、ORDER BY、JOIN 的字段加索引 |
| **避免索引失效** | 不在索引列上做函数运算、避免左模糊、注意最左前缀 |
| **避免 SELECT \*** | 只查需要的字段，能用覆盖索引就用 |
| **分页优化** | 深分页用延迟关联：先查主键再 JOIN 回原表 |
| **JOIN 优化** | 小表驱动大表，被驱动表的关联字段加索引 |
| **减少子查询** | 尽量用 JOIN 代替子查询，子查询可能产生临时表 |

**深分页优化示例**：

```sql
-- ❌ 慢：OFFSET 100000 要扫描前 10 万行再丢弃
SELECT * FROM user ORDER BY id LIMIT 100000, 10;

-- ✅ 快：延迟关联，先用覆盖索引查出主键，再回表取数据
SELECT * FROM user u
INNER JOIN (SELECT id FROM user ORDER BY id LIMIT 100000, 10) t
ON u.id = t.id;
```

**🎤 面试这样答**：
> "排查慢 SQL 的思路是三步：第一步开启慢查询日志定位哪些 SQL 慢；第二步用 EXPLAIN 分析执行计划，看有没有走索引、扫描行数多不多；第三步针对性优化，常见手段包括加合适的索引、避免索引失效、避免 SELECT *、深分页用延迟关联优化、JOIN 时小表驱动大表等。"

---

### 11. EXPLAIN 执行计划怎么看？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：EXPLAIN 是分析 SQL 性能的核心工具，重点关注 type（访问类型）、key（实际用的索引）、rows（扫描行数）、Extra（额外信息）这四个字段。

**通俗理解**：

EXPLAIN 就像给 SQL 做一次"体检报告"。你不需要记住所有指标，重点看几个关键项就行——就像体检报告你主要看血压、血糖、肝功能，不用每项都背。

**原理详解**：

```sql
EXPLAIN SELECT * FROM user WHERE name = '张三';
```

**核心字段解读**：

| 字段 | 含义 | 重点关注 |
|------|------|---------|
| **type** | 访问类型，⚡**最重要** | 从好到差排列，见下方 |
| **key** | 实际使用的索引 | NULL 表示没走索引 |
| **rows** | 预估扫描行数 | 越小越好 |
| **Extra** | 额外信息 | 看有没有 Using index、Using filesort 等 |

**type 字段（访问类型）从好到差排列**：

| type | 含义 | 性能 |
|------|------|------|
| **system/const** | 主键或唯一索引等值查询，最多一行 | ⚡最快 |
| **eq_ref** | JOIN 时被驱动表用主键/唯一索引匹配 | 很快 |
| **ref** | 非唯一索引等值查询 | 快 |
| **range** | 索引范围扫描（`>`, `<`, `BETWEEN`, `IN`） | 还行 |
| **index** | 全索引扫描（遍历整棵索引树） | 慢 |
| **ALL** | ⚡**全表扫描**，必须优化 | 最慢 |

> 一般来说，SQL 优化的目标是让 type 至少达到 ⚡**range** 级别，避免出现 ALL。

**Extra 字段常见值**：

| Extra | 含义 | 好坏 |
|-------|------|------|
| **Using index** | 覆盖索引，不需要回表 | ✅ 好 |
| **Using index condition** | 索引下推（ICP） | ✅ 好 |
| **Using where** | Server 层做了额外过滤 | 一般 |
| **Using filesort** | 额外排序，没用上索引排序 | ⚠️ 需优化 |
| **Using temporary** | 用了临时表（常见于 GROUP BY、DISTINCT） | ⚠️ 需优化 |

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | MySQL 索引的底层数据结构？为什么用 B+ 树？ |
| ⭐⭐⭐⭐⭐ | 聚簇索引和非聚簇索引的区别？ |
| ⭐⭐⭐⭐⭐ | 哪些情况会导致索引失效？ |
| ⭐⭐⭐⭐⭐ | 事务隔离级别？ |
| ⭐⭐⭐⭐⭐ | MVCC 的原理？ |
| ⭐⭐⭐⭐⭐ | 慢 SQL 怎么排查和优化？ |
| ⭐⭐⭐⭐ | 覆盖索引和索引下推？ |
| ⭐⭐⭐⭐ | MySQL 有哪些锁？ |
| ⭐⭐⭐⭐ | ACID 四大特性？ |
| ⭐⭐⭐⭐ | EXPLAIN 执行计划怎么看？ |
| ⭐⭐⭐ | 什么是死锁？怎么解决？ |
