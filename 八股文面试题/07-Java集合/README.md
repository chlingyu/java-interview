# 07 - Java 集合

> 覆盖 Java 集合框架核心知识：ArrayList、LinkedList、HashMap、ConcurrentHashMap 等高频面试考点。Map 部分是面试重灾区，HashMap 几乎每场必问。

---

## 一、List

### 1. ArrayList 和 LinkedList 的区别？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐

**一句话回答**：ArrayList 底层是动态数组，LinkedList 底层是双向链表。实际开发中 ArrayList 几乎全面优于 LinkedList。

**通俗理解**：

想象你在图书馆找书。ArrayList 就像一排编好号的书架，你说"我要第 5 本"，管理员直接走到第 5 格拿给你，超快。但如果要在中间插一本书，后面所有书都得往后挪一格。LinkedList 就像一串用绳子串起来的书，每本书上写着"下一本在哪"。要找第 5 本得从头一本本数过去，但在中间插一本只需要解开绳子重新系上。

**回到技术**："编好号的书架"就是数组的连续内存空间，通过下标直接定位，O(1) 随机访问。"绳子串起来"就是链表的指针引用，插入只需改指针，但查找要遍历。不过理论归理论，实际中 ArrayList 因为内存连续、对 CPU 缓存友好，即使是中间插入也往往比 LinkedList 快。

| 对比项 | ArrayList | LinkedList |
|--------|-----------|------------|
| 底层结构 | **动态数组** | **双向链表** |
| 随机访问（`get(i)`） | ⚡**O(1)**，直接按下标定位 | O(n)，要从头一个个找 |
| 尾部添加（`add(e)`） | ⚡**均摊 O(1)** | O(1) |
| 中间插入/删除 | O(n)，要搬移后面的元素 | O(n)，找到位置后插入本身 O(1)，但找的过程是 O(n) |
| 内存占用 | 紧凑，只存数据本身 | 每个节点额外存两个指针（前驱 + 后继），⚡**内存开销约为 ArrayList 的 3 倍** |

```java
// ArrayList：底层就是一个 Object 数组
Object[] elementData;

// LinkedList：每个元素包装成一个 Node 节点
private static class Node<E> {
    E item;       // 数据
    Node<E> next; // 后继指针
    Node<E> prev; // 前驱指针
}
```

> **实际开发建议**：绝大多数场景直接用 ArrayList。LinkedList 只在"频繁在两端增删、几乎不随机访问"的场景（如实现队列/双端队列）才有优势。

**🎤 面试这样答**：
> "ArrayList 底层是动态数组，支持 O(1) 随机访问，尾部添加均摊 O(1)，但中间插入删除需要搬移元素。LinkedList 底层是双向链表，插入删除只需改指针，但随机访问要从头遍历。理论上各有优劣，但实际开发中 ArrayList 几乎全面优于 LinkedList，因为数组内存连续，对 CPU 缓存非常友好，而 LinkedList 每个节点额外存两个指针，内存开销约是 ArrayList 的 3 倍。所以绝大多数场景直接用 ArrayList。"

---

### 2. ArrayList 的扩容机制？

> ⭐⭐⭐ 常问 | 难度：⭐⭐

**回答**：ArrayList 底层是数组，数组满了就得"搬家"——创建一个更大的新数组，把旧数据复制过去。你可以理解为住的房子太小了，换一套大的，然后把家具全搬过去。

**扩容流程**：

1. 初始容量：`new ArrayList()` 时，底层数组其实是个⚡**空数组**（JDK 7+ 的懒初始化），第一次 `add` 时才扩容为 ⚡**10**
2. 什么时候扩容：当元素个数超过当前数组长度时触发
3. 扩容多少：新容量 = 旧容量 × ⚡**1.5**（准确说是 `oldCapacity + (oldCapacity >> 1)`，右移一位就是除以 2）
4. 怎么搬：调用 `Arrays.copyOf()` 把旧数组数据复制到新数组

```java
// JDK 8 源码简化版
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5 倍
    elementData = Arrays.copyOf(elementData, newCapacity); // 复制到新数组
}
```

> **面试追问**：如果你提前知道要存 1000 个元素，最好用 `new ArrayList<>(1000)` 指定初始容量，避免反复扩容复制带来的性能损耗。

---

## 二、Map

### 3. HashMap 的底层数据结构？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：JDK 8 的 HashMap 底层是 **数组 + 链表 + 红黑树**。

**通俗理解**：

把 HashMap 想象成一个"快递柜"：
- **数组** = 快递柜的格子，一共有若干个编号（默认 ⚡**16** 个）
- **链表** = 如果两个快递被分到同一个格子（哈希冲突），就在这个格子后面排队挂着
- **红黑树** = 如果某个格子后面排的队太长了（⚡**≥ 8 个**），就把队列升级成一棵"查找树"，找东西更快

**回到技术**：上面说的"格子编号"就是 key 的 hashCode 对数组长度取模的结果，决定元素放在哪个位置。"排队"就是链表解决哈希冲突。"升级成查找树"就是链表转红黑树——链表查找是 O(n)，红黑树是 O(log n)，当冲突严重时性能差距很大。

**原理详解**：

```
HashMap 底层结构（JDK 8）

数组（Node[] table）
┌───┬───┬───┬───┬───┬───┬───┬───┐
│ 0 │ 1 │ 2 │ 3 │ 4 │ 5 │ 6 │ 7 │ ...
└─┬─┴───┴─┬─┴───┴───┴─┬─┴───┴───┘
  │       │           │
  ▼       ▼           ▼
[K1,V1] [K3,V3]    [K5,V5]      ← 链表节点
  │                   │
  ▼                   ▼
[K2,V2]            [K6,V6]
                      │
                      ▼
                   [K7,V7]
                      │  （链表长度 ≥ 8 且数组长度 ≥ 64 → 转红黑树）
                      ▼
                   🌳 红黑树
```

**关键数字**：

| 参数 | 值 | 含义 |
|------|-----|------|
| 默认初始容量 | ⚡**16** | 数组初始长度，必须是 2 的幂 |
| 默认负载因子 | ⚡**0.75** | 元素个数达到容量 × 0.75 时触发扩容 |
| 树化阈值 | ⚡**8** | 链表长度 ≥ 8 时**可能**转红黑树 |
| 树化最小容量 | ⚡**64** | 数组长度 ≥ 64 时才真正树化，否则优先扩容 |
| 退化阈值 | ⚡**6** | 红黑树节点 ≤ 6 时退化回链表 |

> **为什么树化阈值是 8？** 根据泊松分布，在负载因子 0.75 的情况下，一个桶中出现 8 个元素的概率只有 ⚡**0.00000006**（千万分之六），属于极端情况。选 8 是在时间和空间之间的平衡——红黑树节点占用的内存是链表节点的 ⚡**2 倍**，不值得在短链表上用。

**🎤 面试这样答**：
> "JDK 8 的 HashMap 底层是数组加链表加红黑树。默认数组长度 16，负载因子 0.75。put 时通过 key 的 hashCode 计算数组下标，如果发生哈希冲突就用链表串起来。当链表长度达到 8 且数组长度达到 64 时，链表会转成红黑树，把查找时间从 O(n) 优化到 O(log n)。当红黑树节点减少到 6 个时会退化回链表。"

---

### 4. HashMap 的 put 流程？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐

**一句话回答**：计算 key 的哈希值定位数组下标，如果为空直接放入，不为空则判断 key 是否相同——相同就覆盖，不同就挂到链表或红黑树上，最后检查是否需要扩容。

**通俗理解**：

你去图书馆还书，流程是这样的：
1. 先看书的分类号，确定放哪个书架（**计算哈希值，定位数组下标**）
2. 走到书架前，发现架子是空的 → 直接放上去（**桶为空，直接插入**）
3. 架子上有书 → 看看是不是同一本书的新版本（**key 相同，覆盖旧值**）
4. 不是同一本 → 在这个架子上往后排（**挂到链表尾部或插入红黑树**）
5. 还完书后，管理员检查图书馆是不是太满了，满了就搬到更大的馆（**检查是否需要扩容**）

**回到技术**："分类号"就是 key 的 hash 值对数组长度取模。"同一本书"就是 key 的 `equals()` 返回 true。"往后排"在 JDK 8 中是**尾插法**（JDK 7 是头插法，多线程下会导致死循环）。

**原理详解**：

```
HashMap.put(key, value) 完整流程

① hash = hash(key)  // 扰动函数：hashCode 高16位异或低16位
        ↓
② table 为空？──是──→ resize() 初始化数组
        ↓ 否
③ table[i] 为空？──是──→ 直接放入新节点
        ↓ 否
④ table[i].key == key？──是──→ 覆盖旧值，返回旧 value
        ↓ 否
⑤ 节点是红黑树？──是──→ 调用树的插入方法
        ↓ 否
⑥ 遍历链表：
   - 找到相同 key → 覆盖
   - 到达尾部 → 尾插新节点
   - 插入后链表长度 ≥ 8 → treeifyBin()（数组 ≥ 64 才真正树化）
        ↓
⑦ ++size > threshold？──是──→ resize() 扩容
```

**扰动函数**——面试常追问"为什么要高低位异或"：

```java
// JDK 8 的 hash() 方法
static final int hash(Object key) {
    int h;
    // key 为 null 放在下标 0 的位置
    // 否则：hashCode 的高 16 位和低 16 位做异或
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

> 为什么要这样做？因为数组长度通常不大（比如 16），取模时只用到了 hashCode 的低几位，高位信息被浪费了。高低位异或让高位也参与运算，**减少哈希冲突**。

**🎤 面试这样答**：
> "HashMap 的 put 流程：首先对 key 做 hash 扰动，高 16 位异或低 16 位减少冲突。然后用 hash & (n-1) 定位数组下标。如果桶为空直接插入；不为空就判断 key 是否相同，相同则覆盖。不同的话，如果是红黑树就走树的插入，否则遍历链表尾插。插入后如果链表长度达到 8 且数组长度达到 64 就树化。最后判断元素总数是否超过阈值，超过就扩容。JDK 8 改用尾插法，解决了 JDK 7 头插法在多线程下的死循环问题。"

---

### 5. HashMap 的扩容机制？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：当元素个数超过 容量 × 负载因子 时，数组扩大为原来的 ⚡**2 倍**，所有元素重新计算位置。

**通俗理解**：

还是快递柜的例子。一开始有 16 个格子，每个格子最多挂几个快递。当快递总数超过 12 个（16 × 0.75）时，快递柜太挤了，换一个 32 格的新柜子，然后把所有快递按新的编号规则重新分配到新格子里。

**回到技术**："换新柜子"就是创建一个 2 倍大小的新数组。"重新分配"就是 **rehash（重新哈希）**——每个元素要重新计算在新数组中的位置。

**原理详解**：

**扩容触发条件**：`size > capacity × loadFactor`（默认就是 `size > 16 × 0.75 = 12`）

**JDK 8 的巧妙优化**——不需要重新算 hash：

扩容后数组长度翻倍（比如 16 → 32），每个元素在新数组中的位置只有两种可能：
- **原位置**（下标不变）
- **原位置 + 旧容量**（比如原来在下标 5，扩容后要么还在 5，要么在 5 + 16 = 21）

怎么判断？只需要看 hash 值新增的那一位是 0 还是 1：

```
旧容量 16 = 0001 0000，扩容后 32 = 0010 0000

hash 值:  xxxx xxxx xxxx xxxx
                          ↑ 看这一位（第 5 位）
                          0 → 留在原位置
                          1 → 原位置 + 16
```

> 这个设计非常巧妙：不需要像 JDK 7 那样重新计算每个元素的 hash，只需要看一个 bit 位，⚡**用位运算代替取模**，效率极高。而且扩容后链表的顺序不会反转，避免了 JDK 7 中多线程扩容导致的链表死循环。

**🎤 面试这样答**：
> "HashMap 在元素个数超过容量乘以负载因子时扩容，新容量是旧容量的 2 倍。JDK 8 的扩容做了优化，不需要重新计算 hash，只需要看 hash 值新增的那一位是 0 还是 1，就能判断元素在新数组中是留在原位还是移到原位置加旧容量的位置。这也是为什么 HashMap 的容量必须是 2 的幂——这样才能用位运算代替取模，同时让扩容时的元素迁移更高效。"

---

### 6. HashMap 为什么线程不安全？

> ⭐⭐⭐⭐ 高频 | 难度：⭐⭐⭐

**一句话回答**：HashMap 的 put 和扩容操作没有加锁，多线程并发时会导致数据覆盖丢失，JDK 7 中还会出现链表死循环。

**通俗理解**：

两个人同时往同一个格子里放快递，一个人放的时候另一个人也在放，结果一个人的快递被另一个人的盖住了——快递丢了。

**回到技术**：HashMap 的所有操作都没有同步机制，多线程并发时主要有以下问题：

**① JDK 8：数据覆盖**

两个线程同时 put，hash 到同一个桶，都判断桶为空，然后各自插入——后插入的覆盖先插入的，**数据丢失**。

```java
// 两个线程同时执行到这一行，都发现 table[i] == null
if ((p = tab[i = (n - 1) & hash]) == null)
    tab[i] = newNode(hash, key, value, null);
// 线程 A 写入后，线程 B 紧接着写入，A 的数据被覆盖
```

**② JDK 7：链表死循环（经典面试题）**

JDK 7 扩容时用**头插法**迁移链表，多线程同时扩容会导致链表形成环，之后 `get()` 操作会陷入死循环，CPU 飙到 100%。

> JDK 8 改用**尾插法**，解决了死循环问题，但数据覆盖问题依然存在。所以多线程场景必须用 `ConcurrentHashMap`。

**🎤 面试这样答**：
> "HashMap 线程不安全主要体现在两方面。JDK 7 中扩容用头插法，多线程并发扩容会导致链表成环，get 时死循环。JDK 8 改成了尾插法解决了死循环，但多线程同时 put 仍然会出现数据覆盖丢失的问题，因为 put 操作没有任何同步措施。多线程场景应该用 ConcurrentHashMap。"

---

### 7. ConcurrentHashMap 如何保证线程安全？

> ⭐⭐⭐⭐⭐ 必考 | 难度：⭐⭐⭐⭐

**一句话回答**：JDK 7 用分段锁（Segment），JDK 8 改为 CAS + synchronized 锁单个桶，粒度更细、并发度更高。

**通俗理解**：

还是快递柜的场景，现在要解决"两个人同时放快递导致丢件"的问题：
- **JDK 7 的方案**（分段锁）= 把快递柜分成 ⚡**16 段**，每段有一把锁。你放第 3 段的快递时，别人还能同时放第 7 段的，互不影响。但同一段内只能一个人操作
- **JDK 8 的方案**（CAS + synchronized）= 不分段了，直接锁单个格子。你放第 3 格时，只锁第 3 格，其他所有格子都能同时操作。粒度从"一段"细化到"一格"

**回到技术**："一段"就是 JDK 7 的 **Segment（分段，本质是一个小的 HashMap）**，默认 16 个 Segment，并发度就是 16。"一格"就是 JDK 8 中数组的一个桶（Node），用 **synchronized 锁住链表/红黑树的头节点**，只要不是同一个桶，就能完全并行。

**原理详解**：

**JDK 7：Segment 分段锁**

```
ConcurrentHashMap（JDK 7）

Segment[] 数组（默认 16 个段，每段一把 ReentrantLock）
┌──────────┬──────────┬──────────┬──────────┐
│ Segment0 │ Segment1 │ Segment2 │   ...    │
│  🔒锁     │  🔒锁     │  🔒锁     │          │
│ ┌──┬──┐  │ ┌──┬──┐  │ ┌──┬──┐  │          │
│ │  │  │  │ │  │  │  │ │  │  │  │          │
│ └──┴──┘  │ └──┴──┘  │ └──┴──┘  │          │
│ 小HashMap │ 小HashMap │ 小HashMap │          │
└──────────┴──────────┴──────────┴──────────┘
```

- 每个 Segment 继承 `ReentrantLock`，自带锁功能
- put 时先定位到 Segment，再锁住这个 Segment 操作
- 缺点：并发度固定为 ⚡**16**，初始化后不能改；数据结构是数组 + 链表，没有红黑树

**JDK 8：CAS + synchronized（重点掌握）**

```java
// JDK 8 的 put 核心逻辑（简化版）
final V putVal(K key, V value) {
    // ① 计算 hash
    int hash = spread(key.hashCode());
    for (Node<K,V>[] tab = table;;) {
        Node<K,V> f;
        // ② 桶为空 → 用 CAS 无锁插入
        if ((f = tab[i]) == null) {
            if (casTabAt(tab, i, null, new Node<>(hash, key, value)))
                break;  // CAS 成功，插入完毕
        }
        // ③ 桶不为空 → synchronized 锁住头节点
        else {
            synchronized (f) {
                // 链表或红黑树的插入逻辑（和 HashMap 类似）
            }
        }
    }
    // ④ 用 addCount() 统计元素个数（也是 CAS）
}
```

| 对比 | JDK 7 | JDK 8 |
|------|-------|-------|
| 锁的粒度 | 锁一个 Segment（一段） | 锁一个桶的头节点（一格） |
| 锁的实现 | `ReentrantLock` | `synchronized`（JDK 8 优化后性能不输 ReentrantLock） |
| 数据结构 | 数组 + 链表 | 数组 + 链表 + 红黑树 |
| 并发度 | 固定 ⚡**16** | 等于数组长度，**动态扩展** |

**🎤 面试这样答**：
> "ConcurrentHashMap 在 JDK 7 中用分段锁实现，把数据分成 16 个 Segment，每个 Segment 一把 ReentrantLock，不同段之间可以并发操作。JDK 8 做了重大改进，废弃了分段锁，改用 CAS 加 synchronized。put 时如果桶为空就用 CAS 无锁插入，桶不为空就用 synchronized 锁住头节点再操作。锁粒度从段级别细化到桶级别，并发度等于数组长度，而且引入了红黑树优化长链表的查询性能。"

---

### 8. HashMap 和 Hashtable 的区别？

> ⭐⭐⭐ 常问 | 难度：⭐⭐

**回答**：简单说，Hashtable 是"上古时代"的线程安全 Map，用 synchronized 锁整个表，性能很差。现在基本没人用了，多线程场景直接用 ConcurrentHashMap。

| 对比项 | HashMap | Hashtable |
|--------|---------|-----------|
| 线程安全 | ❌ 不安全 | ✅ 安全（synchronized 锁整个方法） |
| 性能 | 快 | ⚡**慢很多**，每次操作都要获取锁 |
| null 值 | key 和 value 都⚡**允许 null** | key 和 value 都⚡**不允许 null** |
| 初始容量 | ⚡**16** | ⚡**11** |
| 扩容方式 | 2 倍 | 2 倍 + 1 |
| 继承关系 | 继承 AbstractMap | 继承 Dictionary（已过时） |

> **面试追问**：为什么 ConcurrentHashMap 也不允许 null key/value？因为多线程环境下，`get(key)` 返回 null 时无法区分是"key 不存在"还是"value 就是 null"，会产生二义性。HashMap 单线程下可以用 `containsKey()` 再判断一次，但并发环境下两次调用之间状态可能已经变了。

---

## 三、Set & 通用

### 9. HashSet 的实现原理？

> ⭐⭐⭐ 常问 | 难度：⭐⭐

**回答**：HashSet 底层就是一个 HashMap，元素存在 HashMap 的 key 里，value 统一用一个固定的空对象占位。你可以理解为 HashSet 就是"只用了 key 的 HashMap"。

```java
// HashSet 源码（极度简化）
public class HashSet<E> {
    private transient HashMap<E, Object> map;

    // 所有 value 都指向同一个空对象，纯占位用
    private static final Object PRESENT = new Object();

    public boolean add(E e) {
        return map.put(e, PRESENT) == null; // 利用 HashMap 的 key 不重复特性
    }

    public boolean contains(Object o) {
        return map.containsKey(o); // 直接查 HashMap 的 key
    }
}
```

> 所以 HashSet 的去重原理和 HashMap 判断 key 相同的逻辑一样：先比 `hashCode()`，再比 `equals()`。自定义对象放进 HashSet 时，必须同时重写这两个方法。

---

### 10. fail-fast 和 fail-safe 机制？

> ⭐⭐ 了解 | 难度：⭐⭐

**回答**：简单说，fail-fast 是"一发现有人偷偷改了集合就立刻报错"，fail-safe 是"改了也没关系，我操作的是副本"。

| 对比项 | fail-fast（快速失败） | fail-safe（安全失败） |
|--------|----------------------|----------------------|
| 代表集合 | `ArrayList`、`HashMap` | `CopyOnWriteArrayList`、`ConcurrentHashMap` |
| 遍历时修改 | 抛 ⚡`ConcurrentModificationException` | 不报错，但可能读不到最新数据 |
| 原理 | 内部维护 `modCount`，遍历时发现被改了就抛异常 | 操作的是数据的快照或副本 |
| 适用场景 | 单线程，及时发现 bug | 多线程并发读写 |

```java
// fail-fast 示例：遍历 ArrayList 时删除元素会报错
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
for (String s : list) {
    if ("b".equals(s)) {
        list.remove(s); // 💥 ConcurrentModificationException
    }
}

// 正确做法：用 Iterator 的 remove 方法
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    if ("b".equals(it.next())) {
        it.remove(); // ✅ 安全删除
    }
}
```

---

## 面试高频程度排序（3~5 年）

| 优先级 | 题目 |
|--------|------|
| ⭐⭐⭐⭐⭐ | HashMap 的底层数据结构？ |
| ⭐⭐⭐⭐⭐ | HashMap 的 put 流程？ |
| ⭐⭐⭐⭐⭐ | HashMap 的扩容机制？ |
| ⭐⭐⭐⭐⭐ | ConcurrentHashMap 如何保证线程安全？ |
| ⭐⭐⭐⭐ | ArrayList 和 LinkedList 的区别？ |
| ⭐⭐⭐⭐ | HashMap 为什么线程不安全？ |
| ⭐⭐⭐ | ArrayList 的扩容机制？ |
| ⭐⭐⭐ | HashMap 和 Hashtable 的区别？ |
| ⭐⭐⭐ | HashSet 的实现原理？ |
| ⭐⭐ | fail-fast 和 fail-safe 机制？ |
